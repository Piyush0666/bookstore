{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { KeyCodes, calculatePrecision, classNamesFunction, precisionRound, getNativeProps, getPropsWithDefaults, divProperties } from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SpinButton';\nvar DEFAULT_PROPS = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: {\n    iconName: 'ChevronUpSmall'\n  },\n  decrementButtonIcon: {\n    iconName: 'ChevronDownSmall'\n  }\n};\nvar INITIAL_STEP_DELAY = 400;\nvar STEP_DELAY = 75;\n\nvar useComponentRef = function (props, input, value) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      focus: function () {\n        if (input.current) {\n          input.current.focus();\n        }\n      }\n    };\n  }, [input, value]);\n};\n\nvar noOp = function () {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n/** Clamp the value to the provided min and/or max */\n\n\nvar clampValue = function (value, _a) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n\n  return value;\n};\n\nexport var SpinButtonBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var disabled = props.disabled,\n      label = props.label,\n      min = props.min,\n      max = props.max,\n      step = props.step,\n      defaultValue = props.defaultValue,\n      valueFromProps = props.value,\n      precisionFromProps = props.precision,\n      labelPosition = props.labelPosition,\n      iconProps = props.iconProps,\n      incrementButtonIcon = props.incrementButtonIcon,\n      incrementButtonAriaLabel = props.incrementButtonAriaLabel,\n      decrementButtonIcon = props.decrementButtonIcon,\n      decrementButtonAriaLabel = props.decrementButtonAriaLabel,\n      ariaLabel = props.ariaLabel,\n      ariaDescribedBy = props.ariaDescribedBy,\n      customUpArrowButtonStyles = props.upArrowButtonStyles,\n      customDownArrowButtonStyles = props.downArrowButtonStyles,\n      theme = props.theme,\n      ariaPositionInSet = props.ariaPositionInSet,\n      ariaSetSize = props.ariaSetSize,\n      ariaValueNow = props.ariaValueNow,\n      ariaValueText = props.ariaValueText,\n      className = props.className,\n      inputProps = props.inputProps,\n      onDecrement = props.onDecrement,\n      onIncrement = props.onIncrement,\n      iconButtonProps = props.iconButtonProps,\n      onValidate = props.onValidate,\n      onChange = props.onChange,\n      styles = props.styles;\n  var input = React.useRef(null);\n  var inputId = useId('input');\n  var labelId = useId('Label');\n\n  var _a = React.useState(false),\n      isFocused = _a[0],\n      setIsFocused = _a[1];\n\n  var _b = React.useState(KeyboardSpinDirection.notSpinning),\n      keyboardSpinDirection = _b[0],\n      setKeyboardSpinDirection = _b[1];\n\n  var async = useAsync();\n  var precision = React.useMemo(function () {\n    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n\n  var _c = useControllableValue(valueFromProps, defaultValue !== null && defaultValue !== void 0 ? defaultValue : String(min || 0), onChange),\n      value = _c[0],\n      setValue = _c[1];\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n\n\n  var _d = React.useState(),\n      intermediateValue = _d[0],\n      setIntermediateValue = _d[1];\n\n  var internalState = React.useRef({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined\n  }).current; // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n  var previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(function () {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    disabled: disabled,\n    isFocused: isFocused,\n    keyboardSpinDirection: keyboardSpinDirection,\n    labelPosition: labelPosition,\n    className: className\n  });\n  var nativeProps = getNativeProps(props, divProperties, ['onBlur', 'onFocus', 'className', 'onChange']);\n  /** Validate (commit) function called on blur or enter keypress. */\n\n  var validate = React.useCallback(function (ev) {\n    // Only run validation if the value changed\n    var enteredValue = internalState.latestIntermediateValue;\n\n    if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n      var newValue = void 0;\n\n      if (onValidate) {\n        newValue = onValidate(enteredValue, ev);\n      } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n        // default validation handling\n        newValue = String(clampValue(Number(enteredValue), {\n          min: min,\n          max: max\n        }));\n      }\n\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        // Commit the value if it changed\n        setValue(newValue, ev);\n      }\n    } // Done validating, so clear the intermediate typed value (if any)\n\n\n    setIntermediateValue(undefined);\n  }, [internalState, max, min, onValidate, setValue]);\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n\n  var stop = React.useCallback(function () {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n\n  var updateValue = React.useCallback(function (stepFunction, ev) {\n    ev.persist();\n\n    if (internalState.latestIntermediateValue !== undefined) {\n      // Edge case: if intermediateValue is set, this means that the user was editing the input\n      // text and then started spinning (either with mouse or keyboard). We need to validate and\n      // call onChange before starting to spin.\n      if (ev.type === 'keydown') {\n        // For the arrow keys, we have to manually trigger validation.\n        // (For the buttons, validation will happen automatically since the input's onBlur will\n        // be triggered after mousedown on the button completes.)\n        validate(ev);\n      }\n\n      async.requestAnimationFrame(function () {\n        // After handling any value updates, do the spinning update\n        updateValue(stepFunction, ev);\n      });\n      return;\n    } // Call the step function and update the value.\n    // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n    // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n    // additional calls to the original updateValue function via setTimeout. It also lets us\n    // avoid useCallback deps on frequently changing values.)\n\n\n    var newValue = stepFunction(internalState.latestValue || '', ev);\n\n    if (newValue !== undefined && newValue !== internalState.latestValue) {\n      setValue(newValue, ev);\n    } // Schedule the next spin if applicable\n    // (will be canceled if there's a mouseup before the timeout runs)\n\n\n    var wasSpinning = internalState.spinningByMouse;\n    internalState.spinningByMouse = ev.type === 'mousedown';\n\n    if (internalState.spinningByMouse) {\n      internalState.stepTimeoutHandle = async.setTimeout(function () {\n        updateValue(stepFunction, ev);\n      }, wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY);\n    }\n  }, [internalState, async, validate, setValue]);\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n\n  var handleIncrement = React.useCallback(function (newValue) {\n    if (onIncrement) {\n      return onIncrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) + Number(step), {\n        max: max\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, max, onIncrement, step]);\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n\n  var handleDecrement = React.useCallback(function (newValue) {\n    if (onDecrement) {\n      return onDecrement(newValue);\n    } else {\n      var numericValue = clampValue(Number(newValue) - Number(step), {\n        min: min\n      });\n      numericValue = precisionRound(numericValue, precision);\n      return String(numericValue);\n    }\n  }, [precision, min, onDecrement, step]);\n  /** Handles when the user types in the input */\n\n  var handleInputChange = function (ev) {\n    setIntermediateValue(ev.target.value);\n  };\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n\n\n  var handleFocus = function (ev) {\n    var _a; // We can't set focus on a non-existing element\n\n\n    if (!input.current) {\n      return;\n    }\n\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n\n    input.current.select();\n    setIsFocused(true);\n    (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n\n\n  var handleBlur = function (ev) {\n    var _a;\n\n    validate(ev);\n    setIsFocused(false);\n    (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n  };\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n\n\n  var handleKeyDown = function (ev) {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    var spinDirection = KeyboardSpinDirection.notSpinning; // eslint-disable-next-line deprecation/deprecation\n\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    } // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n\n\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n\n\n  var handleKeyUp = React.useCallback(function (ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n      stop();\n      return;\n    }\n  }, [disabled, stop]);\n  var handleIncrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleIncrement, ev);\n  }, [handleIncrement, updateValue]);\n  var handleDecrementMouseDown = React.useCallback(function (ev) {\n    updateValue(handleDecrement, ev);\n  }, [handleDecrement, updateValue]);\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n  var valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  var labelContent = (iconProps || label) && React.createElement(\"div\", {\n    className: classNames.labelWrapper\n  }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n    className: classNames.icon,\n    \"aria-hidden\": \"true\"\n  })), label && React.createElement(Label, {\n    id: labelId,\n    htmlFor: inputId,\n    className: classNames.label,\n    disabled: disabled\n  }, label));\n  return React.createElement(\"div\", {\n    className: classNames.root,\n    ref: ref\n  }, labelPosition !== Position.bottom && labelContent, React.createElement(\"div\", __assign({}, nativeProps, {\n    className: classNames.spinButtonWrapper,\n    \"aria-label\": ariaLabel && ariaLabel,\n    \"aria-posinset\": ariaPositionInSet,\n    \"aria-setsize\": ariaSetSize,\n    \"data-ktp-target\": true\n  }), React.createElement(\"input\", __assign({\n    // Display intermediateValue while editing the text (before commit)\n    value: intermediateValue !== null && intermediateValue !== void 0 ? intermediateValue : value,\n    id: inputId,\n    onChange: noOp,\n    onInput: handleInputChange,\n    className: classNames.input,\n    type: \"text\",\n    autoComplete: \"off\",\n    role: \"spinbutton\",\n    \"aria-labelledby\": label && labelId,\n    \"aria-valuenow\": ariaValueNow !== null && ariaValueNow !== void 0 ? ariaValueNow : valueIsNumber ? Number(value) : undefined,\n    \"aria-valuetext\": ariaValueText !== null && ariaValueText !== void 0 ? ariaValueText : valueIsNumber ? undefined : value,\n    \"aria-valuemin\": min,\n    \"aria-valuemax\": max,\n    \"aria-describedby\": ariaDescribedBy,\n    onBlur: handleBlur,\n    ref: input,\n    onFocus: handleFocus,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    disabled: disabled,\n    \"aria-disabled\": disabled,\n    \"data-lpignore\": true,\n    \"data-ktp-execute-target\": true\n  }, inputProps)), React.createElement(\"span\", {\n    className: classNames.arrowButtonsContainer\n  }, React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n    className: 'ms-UpButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n    disabled: disabled,\n    iconProps: incrementButtonIcon,\n    onMouseDown: handleIncrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: incrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)), React.createElement(IconButton, __assign({\n    styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n    className: 'ms-DownButton',\n    checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n    disabled: disabled,\n    iconProps: decrementButtonIcon,\n    onMouseDown: handleDecrementMouseDown,\n    onMouseLeave: stop,\n    onMouseUp: stop,\n    tabIndex: -1,\n    ariaLabel: decrementButtonAriaLabel,\n    \"data-is-focusable\": false\n  }, iconButtonProps)))), labelPosition === Position.bottom && labelContent);\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nvar useDebugWarnings = function (props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        value: 'defaultValue'\n      }\n    });\n  }\n};","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SACEC,QADF,EAEEC,kBAFF,EAGEC,kBAHF,EAIEC,cAJF,EAKEC,cALF,EAMEC,oBANF,EAOEC,aAPF,QAQO,iBARP;AASA,SAASC,oBAAT,QAAqC,qBAArC;AACA,SAASC,qBAAT,QAAsC,oBAAtC;AACA,SAASC,QAAT,QAAyB,mBAAzB;AACA,SAASC,QAAT,EAAmBC,oBAAnB,EAAyCC,WAAzC,EAAsDC,KAAtD,EAA6DC,WAA7D,QAAgF,uBAAhF;AAYA,IAAMC,aAAa,GAAGb,kBAAkB,EAAxC;AAEA,IAAMc,cAAc,GAAG,YAAvB;AACA,IAAMC,aAAa,GAOf;EACFC,QAAQ,EAAE,KADR;EAEFC,KAAK,EAAE,EAFL;EAGFC,IAAI,EAAE,CAHJ;EAIFC,aAAa,EAAEZ,QAAQ,CAACa,KAJtB;EAKFC,mBAAmB,EAAE;IAAEC,QAAQ,EAAE;EAAZ,CALnB;EAMFC,mBAAmB,EAAE;IAAED,QAAQ,EAAE;EAAZ;AANnB,CAPJ;AAiBA,IAAME,kBAAkB,GAAG,GAA3B;AACA,IAAMC,UAAU,GAAG,EAAnB;;AAEA,IAAMC,eAAe,GAAG,UACtBC,KADsB,EAEtBC,KAFsB,EAGtBC,KAHsB,EAGG;EAEzBnC,KAAK,CAACoC,mBAAN,CACEH,KAAK,CAACI,YADR,EAEE;IAAM,OAAC;MACL,IAAIF,KAAJ,GAAS;QACP,OAAOA,KAAP;MACD,CAHI;;MAILG,KAAK;QACH,IAAIJ,KAAK,CAACK,OAAV,EAAmB;UACjBL,KAAK,CAACK,OAAN,CAAcD,KAAd;QACD;MACF;IARI,CAAD;EASJ,CAXJ,EAYE,CAACJ,KAAD,EAAQC,KAAR,CAZF;AAcD,CAnBD;;AAqBA,IAAMK,IAAI,GAAG;EACX;;;;;;;;;AASD,CAVD;AAYA;;;AACA,IAAMC,UAAU,GAAG,UAACN,KAAD,EAAgBO,EAAhB,EAA4D;MAA1CC,GAAG;MAAEC,GAAG;;EAC3C,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC3BT,KAAK,GAAGU,IAAI,CAACF,GAAL,CAASR,KAAT,EAAgBS,GAAhB,CAAR;EACD;;EACD,IAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;IAC3BR,KAAK,GAAGU,IAAI,CAACD,GAAL,CAAST,KAAT,EAAgBQ,GAAhB,CAAR;EACD;;EACD,OAAOR,KAAP;AACD,CARD;;AAUA,OAAO,IAAMW,cAAc,GAA8C9C,KAAK,CAAC+C,UAAN,CAGvE,UAACC,oBAAD,EAAuBC,GAAvB,EAA0B;EAC1B,IAAMhB,KAAK,GAAGxB,oBAAoB,CAACY,aAAD,EAAgB2B,oBAAhB,CAAlC;EAEE,YAAQ,GA+BNf,KAAK,SA/BP;EAAA,IACAV,KAAK,GA8BHU,KAAK,MA/BP;EAAA,IAEAU,GAAG,GA6BDV,KAAK,IA/BP;EAAA,IAGAW,GAAG,GA4BDX,KAAK,IA/BP;EAAA,IAIAT,IAAI,GA2BFS,KAAK,KA/BP;EAAA,IAKAiB,YAAY,GA0BVjB,KAAK,aA/BP;EAAA,IAMOkB,cAAc,GAyBnBlB,KAAK,MA/BP;EAAA,IAOWmB,kBAAkB,GAwB3BnB,KAAK,UA/BP;EAAA,IAQAR,aAAa,GAuBXQ,KAAK,cA/BP;EAAA,IASAoB,SAAS,GAsBPpB,KAAK,UA/BP;EAAA,IAUAN,mBAAmB,GAqBjBM,KAAK,oBA/BP;EAAA,IAWAqB,wBAAwB,GAoBtBrB,KAAK,yBA/BP;EAAA,IAYAJ,mBAAmB,GAmBjBI,KAAK,oBA/BP;EAAA,IAaAsB,wBAAwB,GAkBtBtB,KAAK,yBA/BP;EAAA,IAcAuB,SAAS,GAiBPvB,KAAK,UA/BP;EAAA,IAeAwB,eAAe,GAgBbxB,KAAK,gBA/BP;EAAA,IAgBqByB,yBAAyB,GAe5CzB,KAAK,oBA/BP;EAAA,IAiBuB0B,2BAA2B,GAchD1B,KAAK,sBA/BP;EAAA,IAkBA2B,KAAK,GAaH3B,KAAK,MA/BP;EAAA,IAmBA4B,iBAAiB,GAYf5B,KAAK,kBA/BP;EAAA,IAoBA6B,WAAW,GAWT7B,KAAK,YA/BP;EAAA,IAqBA8B,YAAY,GAUV9B,KAAK,aA/BP;EAAA,IAsBA+B,aAAa,GASX/B,KAAK,cA/BP;EAAA,IAuBAgC,SAAS,GAQPhC,KAAK,UA/BP;EAAA,IAwBAiC,UAAU,GAORjC,KAAK,WA/BP;EAAA,IAyBAkC,WAAW,GAMTlC,KAAK,YA/BP;EAAA,IA0BAmC,WAAW,GAKTnC,KAAK,YA/BP;EAAA,IA2BAoC,eAAe,GAIbpC,KAAK,gBA/BP;EAAA,IA4BAqC,UAAU,GAGRrC,KAAK,WA/BP;EAAA,IA6BAsC,QAAQ,GAENtC,KAAK,SA/BP;EAAA,IA8BAuC,MAAM,GACJvC,KAAK,OA/BP;EAiCF,IAAMC,KAAK,GAAGlC,KAAK,CAACyE,MAAN,CAA+B,IAA/B,CAAd;EACA,IAAMC,OAAO,GAAGzD,KAAK,CAAC,OAAD,CAArB;EACA,IAAM0D,OAAO,GAAG1D,KAAK,CAAC,OAAD,CAArB;;EAEM,SAA4BjB,KAAK,CAAC4E,QAAN,CAAe,KAAf,CAA5B;EAAA,IAACC,SAAS,QAAV;EAAA,IAAYC,YAAY,QAAxB;;EACA,SAAoD9E,KAAK,CAAC4E,QAAN,CAAehE,qBAAqB,CAACmE,WAArC,CAApD;EAAA,IAACC,qBAAqB,QAAtB;EAAA,IAAwBC,wBAAwB,QAAhD;;EACN,IAAMC,KAAK,GAAGpE,QAAQ,EAAtB;EAEA,IAAMqE,SAAS,GAAGnF,KAAK,CAACoF,OAAN,CAAc;IAC9B,OAAOhC,kBAAkB,SAAlB,sBAAkB,WAAlB,wBAAsBP,IAAI,CAACD,GAAL,CAASvC,kBAAkB,CAACmB,IAAD,CAA3B,EAAmC,CAAnC,CAA7B;EACD,CAFiB,EAEf,CAAC4B,kBAAD,EAAqB5B,IAArB,CAFe,CAAlB;EAIA;;;;;;;EAMM,SAAoBT,oBAAoB,CAACoC,cAAD,EAAiBD,YAAY,SAAZ,gBAAY,WAAZ,kBAAgBmC,MAAM,CAAC1C,GAAG,IAAI,CAAR,CAAvC,EAAmD4B,QAAnD,CAAxC;EAAA,IAACpC,KAAK,QAAN;EAAA,IAAQmD,QAAQ,QAAhB;EACN;;;;;;;EAKM,SAA4CtF,KAAK,CAAC4E,QAAN,EAA5C;EAAA,IAACW,iBAAiB,QAAlB;EAAA,IAAoBC,oBAAoB,QAAxC;;EAEE,IAASC,aAAa,GAAKzF,KAAK,CAACyE,MAAN,CAAuC;IACxEiB,iBAAiB,EAAE,CAAC,CADoD;IAExEC,WAAW,EAAEC,SAF2D;IAGxEC,uBAAuB,EAAED;EAH+C,CAAvC,EAIjCrD,OAJM,CA9DkB,CAmE1B;EACA;;EACAkD,aAAa,CAACE,WAAd,GAA4BxD,KAA5B;EACAsD,aAAa,CAACI,uBAAd,GAAwCN,iBAAxC;EAEA,IAAMO,sBAAsB,GAAG5E,WAAW,CAACiC,cAAD,CAA1C;EACAnD,KAAK,CAAC+F,SAAN,CAAgB;IACd;IACA,IAAI5C,cAAc,KAAK2C,sBAAnB,IAA6CP,iBAAiB,KAAKK,SAAvE,EAAkF;MAChFJ,oBAAoB,CAACI,SAAD,CAApB;IACD;EACF,CALD,EAKG,CAACzC,cAAD,EAAiB2C,sBAAjB,EAAyCP,iBAAzC,CALH;EAOA,IAAMS,UAAU,GAAG7E,aAAa,CAACqD,MAAD,EAAS;IACvCZ,KAAK,EAAEA,KADgC;IAEvCtC,QAAQ,UAF+B;IAGvCuD,SAAS,WAH8B;IAIvCG,qBAAqB,uBAJkB;IAKvCvD,aAAa,eAL0B;IAMvCwC,SAAS;EAN8B,CAAT,CAAhC;EASA,IAAMgC,WAAW,GAAGzF,cAAc,CAAuCyB,KAAvC,EAA8CvB,aAA9C,EAA6D,CAC7F,QAD6F,EAE7F,SAF6F,EAG7F,WAH6F,EAI7F,UAJ6F,CAA7D,CAAlC;EAOA;;EACA,IAAMwF,QAAQ,GAAGlG,KAAK,CAACmG,WAAN,CACf,UAACC,EAAD,EAAsC;IACpC;IACA,IAAMC,YAAY,GAAGZ,aAAa,CAACI,uBAAnC;;IACA,IAAIQ,YAAY,KAAKT,SAAjB,IAA8BS,YAAY,KAAKZ,aAAa,CAACE,WAAjE,EAA8E;MAC5E,IAAIW,QAAQ,SAAZ;;MACA,IAAIhC,UAAJ,EAAgB;QACdgC,QAAQ,GAAGhC,UAAU,CAAC+B,YAAD,EAAeD,EAAf,CAArB;MACD,CAFD,MAEO,IAAIC,YAAY,IAAIA,YAAY,CAACE,IAAb,GAAoBC,MAApC,IAA8C,CAACC,KAAK,CAACC,MAAM,CAACL,YAAD,CAAP,CAAxD,EAAgF;QACrF;QACAC,QAAQ,GAAGjB,MAAM,CAAC5C,UAAU,CAACiE,MAAM,CAACL,YAAD,CAAP,EAAuB;UAAE1D,GAAG,KAAL;UAAOC,GAAG;QAAV,CAAvB,CAAX,CAAjB;MACD;;MACD,IAAI0D,QAAQ,KAAKV,SAAb,IAA0BU,QAAQ,KAAKb,aAAa,CAACE,WAAzD,EAAsE;QACpE;QACAL,QAAQ,CAACgB,QAAD,EAAWF,EAAX,CAAR;MACD;IACF,CAfmC,CAiBpC;;;IACAZ,oBAAoB,CAACI,SAAD,CAApB;EACD,CApBc,EAqBf,CAACH,aAAD,EAAgB7C,GAAhB,EAAqBD,GAArB,EAA0B2B,UAA1B,EAAsCgB,QAAtC,CArBe,CAAjB;EAwBA;;;;EAGA,IAAMqB,IAAI,GAAG3G,KAAK,CAACmG,WAAN,CAAkB;IAC7B,IAAIV,aAAa,CAACC,iBAAd,IAAmC,CAAvC,EAA0C;MACxCR,KAAK,CAAC0B,YAAN,CAAmBnB,aAAa,CAACC,iBAAjC;MACAD,aAAa,CAACC,iBAAd,GAAkC,CAAC,CAAnC;IACD;;IACD,IAAID,aAAa,CAACoB,eAAd,IAAiC7B,qBAAqB,KAAKpE,qBAAqB,CAACmE,WAArF,EAAkG;MAChGU,aAAa,CAACoB,eAAd,GAAgC,KAAhC;MACA5B,wBAAwB,CAACrE,qBAAqB,CAACmE,WAAvB,CAAxB;IACD;EACF,CATY,EASV,CAACU,aAAD,EAAgBT,qBAAhB,EAAuCE,KAAvC,CATU,CAAb;EAWA;;;;;;;EAMA,IAAM4B,WAAW,GAAG9G,KAAK,CAACmG,WAAN,CAClB,UACEY,YADF,EAEEX,EAFF,EAE2E;IAEzEA,EAAE,CAACY,OAAH;;IAEA,IAAIvB,aAAa,CAACI,uBAAd,KAA0CD,SAA9C,EAAyD;MACvD;MACA;MACA;MACA,IAAIQ,EAAE,CAACa,IAAH,KAAY,SAAhB,EAA2B;QACzB;QACA;QACA;QACAf,QAAQ,CAACE,EAAD,CAAR;MACD;;MACDlB,KAAK,CAACgC,qBAAN,CAA4B;QAC1B;QACAJ,WAAW,CAACC,YAAD,EAAeX,EAAf,CAAX;MACD,CAHD;MAIA;IACD,CAnBwE,CAqBzE;IACA;IACA;IACA;IACA;;;IACA,IAAME,QAAQ,GAAGS,YAAY,CAACtB,aAAa,CAACE,WAAd,IAA6B,EAA9B,EAAkCS,EAAlC,CAA7B;;IACA,IAAIE,QAAQ,KAAKV,SAAb,IAA0BU,QAAQ,KAAKb,aAAa,CAACE,WAAzD,EAAsE;MACpEL,QAAQ,CAACgB,QAAD,EAAWF,EAAX,CAAR;IACD,CA7BwE,CA+BzE;IACA;;;IACA,IAAMe,WAAW,GAAG1B,aAAa,CAACoB,eAAlC;IACApB,aAAa,CAACoB,eAAd,GAAgCT,EAAE,CAACa,IAAH,KAAY,WAA5C;;IACA,IAAIxB,aAAa,CAACoB,eAAlB,EAAmC;MACjCpB,aAAa,CAACC,iBAAd,GAAkCR,KAAK,CAACkC,UAAN,CAChC;QACEN,WAAW,CAACC,YAAD,EAAeX,EAAf,CAAX;MACD,CAH+B,EAIhCe,WAAW,GAAGpF,UAAH,GAAgBD,kBAJK,CAAlC;IAMD;EACF,CA9CiB,EA+ClB,CAAC2D,aAAD,EAAgBP,KAAhB,EAAuBgB,QAAvB,EAAiCZ,QAAjC,CA/CkB,CAApB;EAkDA;;EACA,IAAM+B,eAAe,GAAGrH,KAAK,CAACmG,WAAN,CACtB,UAACG,QAAD,EAAiB;IACf,IAAIlC,WAAJ,EAAiB;MACf,OAAOA,WAAW,CAACkC,QAAD,CAAlB;IACD,CAFD,MAEO;MACL,IAAIgB,YAAY,GAAG7E,UAAU,CAACiE,MAAM,CAACJ,QAAD,CAAN,GAAmBI,MAAM,CAAClF,IAAD,CAA1B,EAAkC;QAAEoB,GAAG;MAAL,CAAlC,CAA7B;MACA0E,YAAY,GAAG/G,cAAc,CAAC+G,YAAD,EAAenC,SAAf,CAA7B;MACA,OAAOE,MAAM,CAACiC,YAAD,CAAb;IACD;EACF,CATqB,EAUtB,CAACnC,SAAD,EAAYvC,GAAZ,EAAiBwB,WAAjB,EAA8B5C,IAA9B,CAVsB,CAAxB;EAaA;;EACA,IAAM+F,eAAe,GAAGvH,KAAK,CAACmG,WAAN,CACtB,UAACG,QAAD,EAAiB;IACf,IAAInC,WAAJ,EAAiB;MACf,OAAOA,WAAW,CAACmC,QAAD,CAAlB;IACD,CAFD,MAEO;MACL,IAAIgB,YAAY,GAAG7E,UAAU,CAACiE,MAAM,CAACJ,QAAD,CAAN,GAAmBI,MAAM,CAAClF,IAAD,CAA1B,EAAkC;QAAEmB,GAAG;MAAL,CAAlC,CAA7B;MACA2E,YAAY,GAAG/G,cAAc,CAAC+G,YAAD,EAAenC,SAAf,CAA7B;MACA,OAAOE,MAAM,CAACiC,YAAD,CAAb;IACD;EACF,CATqB,EAUtB,CAACnC,SAAD,EAAYxC,GAAZ,EAAiBwB,WAAjB,EAA8B3C,IAA9B,CAVsB,CAAxB;EAaA;;EACA,IAAMgG,iBAAiB,GAAG,UAACpB,EAAD,EAAsC;IAC9DZ,oBAAoB,CAAEY,EAAE,CAACqB,MAAH,CAA+BtF,KAAjC,CAApB;EACD,CAFD;EAIA;;;EACA,IAAMuF,WAAW,GAAG,UAACtB,EAAD,EAAuC;WAAA,CACzD;;;IACA,IAAI,CAAClE,KAAK,CAACK,OAAX,EAAoB;MAClB;IACD;;IACD,IAAIkD,aAAa,CAACoB,eAAd,IAAiC7B,qBAAqB,KAAKpE,qBAAqB,CAACmE,WAArF,EAAkG;MAChG4B,IAAI;IACL;;IACDzE,KAAK,CAACK,OAAN,CAAcoF,MAAd;IACA7C,YAAY,CAAC,IAAD,CAAZ;IACA,WAAK,CAAC8C,OAAN,MAAa,IAAb,IAAalF,aAAb,GAAa,MAAb,GAAaA,QAAbT,KAAa,EAAGmE,EAAH,CAAb;EACD,CAXD;EAaA;;;EACA,IAAMyB,UAAU,GAAG,UAACzB,EAAD,EAAuC;;;IACxDF,QAAQ,CAACE,EAAD,CAAR;IACAtB,YAAY,CAAC,KAAD,CAAZ;IACA,WAAK,CAACgD,MAAN,MAAY,IAAZ,IAAYpF,aAAZ,GAAY,MAAZ,GAAYA,QAAZT,KAAY,EAAGmE,EAAH,CAAZ;EACD,CAJD;EAMA;;;EACA,IAAM2B,aAAa,GAAG,UAAC3B,EAAD,EAA0C;IAC9D;IACA;IACA;IACA,IAAIA,EAAE,CAAC4B,KAAH,KAAa5H,QAAQ,CAAC6H,EAAtB,IAA4B7B,EAAE,CAAC4B,KAAH,KAAa5H,QAAQ,CAAC8H,IAAlD,IAA0D9B,EAAE,CAAC4B,KAAH,KAAa5H,QAAQ,CAAC+H,KAApF,EAA2F;MACzF/B,EAAE,CAACgC,cAAH;MACAhC,EAAE,CAACiC,eAAH;IACD;;IACD,IAAI/G,QAAJ,EAAc;MACZqF,IAAI;MACJ;IACD;;IAED,IAAI2B,aAAa,GAAG1H,qBAAqB,CAACmE,WAA1C,CAb8D,CAe9D;;IACA,QAAQqB,EAAE,CAAC4B,KAAX;MACE,KAAK5H,QAAQ,CAAC6H,EAAd;QACEK,aAAa,GAAG1H,qBAAqB,CAACqH,EAAtC;QACAnB,WAAW,CAACO,eAAD,EAAkBjB,EAAlB,CAAX;QACA;;MACF,KAAKhG,QAAQ,CAAC8H,IAAd;QACEI,aAAa,GAAG1H,qBAAqB,CAACsH,IAAtC;QACApB,WAAW,CAACS,eAAD,EAAkBnB,EAAlB,CAAX;QACA;;MACF,KAAKhG,QAAQ,CAAC+H,KAAd;QACE;QACAjC,QAAQ,CAACE,EAAD,CAAR;QACA;;MACF,KAAKhG,QAAQ,CAACmI,MAAd;QACE;QACA/C,oBAAoB,CAACI,SAAD,CAApB;QACA;IAhBJ,CAhB8D,CAkC9D;IACA;;;IACA,IAAIZ,qBAAqB,KAAKsD,aAA9B,EAA6C;MAC3CrD,wBAAwB,CAACqD,aAAD,CAAxB;IACD;EACF,CAvCD;EAyCA;;;EACA,IAAME,WAAW,GAAGxI,KAAK,CAACmG,WAAN,CAClB,UAACC,EAAD,EAAqC;IACnC;IACA,IAAI9E,QAAQ,IAAI8E,EAAE,CAAC4B,KAAH,KAAa5H,QAAQ,CAAC6H,EAAlC,IAAwC7B,EAAE,CAAC4B,KAAH,KAAa5H,QAAQ,CAAC8H,IAAlE,EAAwE;MACtEvB,IAAI;MACJ;IACD;EACF,CAPiB,EAQlB,CAACrF,QAAD,EAAWqF,IAAX,CARkB,CAApB;EAWA,IAAM8B,wBAAwB,GAAGzI,KAAK,CAACmG,WAAN,CAC/B,UAACC,EAAD,EAAkC;IAChCU,WAAW,CAACO,eAAD,EAAkBjB,EAAlB,CAAX;EACD,CAH8B,EAI/B,CAACiB,eAAD,EAAkBP,WAAlB,CAJ+B,CAAjC;EAOA,IAAM4B,wBAAwB,GAAG1I,KAAK,CAACmG,WAAN,CAC/B,UAACC,EAAD,EAAkC;IAChCU,WAAW,CAACS,eAAD,EAAkBnB,EAAlB,CAAX;EACD,CAH8B,EAI/B,CAACmB,eAAD,EAAkBT,WAAlB,CAJ+B,CAAjC;EAOA9E,eAAe,CAACC,KAAD,EAAQC,KAAR,EAAeC,KAAf,CAAf;EACAwG,gBAAgB,CAAC1G,KAAD,CAAhB;EAEA,IAAM2G,aAAa,GAAG,CAAC,CAACzG,KAAF,IAAW,CAACsE,KAAK,CAACC,MAAM,CAACvE,KAAD,CAAP,CAAvC,CA5T0B,CA4T8B;;EAExD,IAAM0G,YAAY,GAAG,CAACxF,SAAS,IAAI9B,KAAd,KACnBvB;IAAKiE,SAAS,EAAE+B,UAAU,CAAC8C;EAA3B,GACGzF,SAAS,IAAIrD,oBAACG,IAAD,EAAK4I,aAAK1F,SAAL,EAAc;IAAEY,SAAS,EAAE+B,UAAU,CAACgD,IAAxB;IAA4B,eAAc;EAA1C,CAAd,CAAL,CADhB,EAEGzH,KAAK,IACJvB,oBAACE,KAAD,EAAM;IAAC+I,EAAE,EAAEtE,OAAL;IAAcuE,OAAO,EAAExE,OAAvB;IAAgCT,SAAS,EAAE+B,UAAU,CAACzE,KAAtD;IAA6DD,QAAQ,EAAEA;EAAvE,CAAN,EACGC,KADH,CAHJ,CADF;EAWA,OACEvB;IAAKiE,SAAS,EAAE+B,UAAU,CAACmD,IAA3B;IAAiClG,GAAG,EAAEA;EAAtC,GACGxB,aAAa,KAAKZ,QAAQ,CAACuI,MAA3B,IAAqCP,YADxC,EAEE7I,wCACMiG,WADN,EACiB;IACfhC,SAAS,EAAE+B,UAAU,CAACqD,iBADP;IACwB,cAC3B7F,SAAS,IAAIA,SAFV;IAEmB,iBACnBK,iBAHA;IAGiB,gBAClBC,WAJC;IAIU,mBACR;EALF,CADjB,GAQE9D;IACE;IACAmC,KAAK,EAAEoD,iBAAiB,SAAjB,qBAAiB,WAAjB,uBAAqBpD,KAF9B;IAGE8G,EAAE,EAAEvE,OAHN;IAIEH,QAAQ,EAAE/B,IAJZ;IAKE8G,OAAO,EAAE9B,iBALX;IAMEvD,SAAS,EAAE+B,UAAU,CAAC9D,KANxB;IAOE+E,IAAI,EAAC,MAPP;IAQEsC,YAAY,EAAC,KARf;IASEC,IAAI,EAAC,YATP;IASmB,mBACAjI,KAAK,IAAIoD,OAV5B;IAUmC,iBAElBZ,YAAY,SAAZ,gBAAY,WAAZ,kBAAiB6E,aAAa,GAAGlC,MAAM,CAACvE,KAAD,CAAT,GAAmByD,SAZlE;IAY4E,kBAC1D5B,aAAa,SAAb,iBAAa,WAAb,mBAAkB4E,aAAa,GAAGhD,SAAH,GAAezD,KAbhE;IAasE,iBACrDQ,GAdjB;IAcoB,iBACHC,GAfjB;IAeoB,oBACAa,eAhBpB;IAiBEqE,MAAM,EAAED,UAjBV;IAkBE5E,GAAG,EAAEf,KAlBP;IAmBE0F,OAAO,EAAEF,WAnBX;IAoBE+B,SAAS,EAAE1B,aApBb;IAqBE2B,OAAO,EAAElB,WArBX;IAsBElH,QAAQ,EAAEA,QAtBZ;IAsBoB,iBACHA,QAvBjB;IAuByB,qBAvBzB;IAuByB,2BAEE;EAzB3B,GA0BM4C,UA1BN,EARF,EAoCElE;IAAMiE,SAAS,EAAE+B,UAAU,CAAC2D;EAA5B,GACE3J,oBAACC,UAAD,EAAW8I;IACTvE,MAAM,EAAE7D,oBAAoB,CAACiD,KAAD,EAAS,IAAT,EAAeF,yBAAf,CADnB;IAETO,SAAS,EAAE,aAFF;IAGT2F,OAAO,EAAE5E,qBAAqB,KAAKpE,qBAAqB,CAACqH,EAHhD;IAIT3G,QAAQ,EAAEA,QAJD;IAKT+B,SAAS,EAAE1B,mBALF;IAMTkI,WAAW,EAAEpB,wBANJ;IAOTqB,YAAY,EAAEnD,IAPL;IAQToD,SAAS,EAAEpD,IARF;IASTqD,QAAQ,EAAE,CAAC,CATF;IAUTxG,SAAS,EAAEF,wBAVF;IAU0B,qBAChB;EAXV,GAYLe,eAZK,CAAX,CADF,EAeErE,oBAACC,UAAD,EAAW8I;IACTvE,MAAM,EAAE7D,oBAAoB,CAACiD,KAAD,EAAS,KAAT,EAAgBD,2BAAhB,CADnB;IAETM,SAAS,EAAE,eAFF;IAGT2F,OAAO,EAAE5E,qBAAqB,KAAKpE,qBAAqB,CAACsH,IAHhD;IAIT5G,QAAQ,EAAEA,QAJD;IAKT+B,SAAS,EAAExB,mBALF;IAMTgI,WAAW,EAAEnB,wBANJ;IAOToB,YAAY,EAAEnD,IAPL;IAQToD,SAAS,EAAEpD,IARF;IASTqD,QAAQ,EAAE,CAAC,CATF;IAUTxG,SAAS,EAAED,wBAVF;IAU0B,qBAChB;EAXV,GAYLc,eAZK,CAAX,CAfF,CApCF,CAFF,EAqEG5C,aAAa,KAAKZ,QAAQ,CAACuI,MAA3B,IAAqCP,YArExC,CADF;AAyED,CArZwE,CAAlE;AAsZP/F,cAAc,CAACmH,WAAf,GAA6B7I,cAA7B;;AAEA,IAAMuH,gBAAgB,GAAG,UAAC1G,KAAD,EAAwB;EAC/C,IAAIiI,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACApJ,WAAW,CAAC;MACVqJ,IAAI,EAAEjJ,cADI;MAEVa,KAAK,OAFK;MAGVqI,iBAAiB,EAAE;QAAEnI,KAAK,EAAE;MAAT;IAHT,CAAD,CAAX;EAKD;AACF,CATD","names":["React","IconButton","Label","Icon","KeyCodes","calculatePrecision","classNamesFunction","precisionRound","getNativeProps","getPropsWithDefaults","divProperties","getArrowButtonStyles","KeyboardSpinDirection","Position","useAsync","useControllableValue","useWarnings","useId","usePrevious","getClassNames","COMPONENT_NAME","DEFAULT_PROPS","disabled","label","step","labelPosition","start","incrementButtonIcon","iconName","decrementButtonIcon","INITIAL_STEP_DELAY","STEP_DELAY","useComponentRef","props","input","value","useImperativeHandle","componentRef","focus","current","noOp","clampValue","_a","min","max","Math","SpinButtonBase","forwardRef","propsWithoutDefaults","ref","defaultValue","valueFromProps","precisionFromProps","iconProps","incrementButtonAriaLabel","decrementButtonAriaLabel","ariaLabel","ariaDescribedBy","customUpArrowButtonStyles","customDownArrowButtonStyles","theme","ariaPositionInSet","ariaSetSize","ariaValueNow","ariaValueText","className","inputProps","onDecrement","onIncrement","iconButtonProps","onValidate","onChange","styles","useRef","inputId","labelId","useState","isFocused","setIsFocused","notSpinning","keyboardSpinDirection","setKeyboardSpinDirection","async","precision","useMemo","String","setValue","intermediateValue","setIntermediateValue","internalState","stepTimeoutHandle","latestValue","undefined","latestIntermediateValue","previousValueFromProps","useEffect","classNames","nativeProps","validate","useCallback","ev","enteredValue","newValue","trim","length","isNaN","Number","stop","clearTimeout","spinningByMouse","updateValue","stepFunction","persist","type","requestAnimationFrame","wasSpinning","setTimeout","handleIncrement","numericValue","handleDecrement","handleInputChange","target","handleFocus","select","onFocus","handleBlur","onBlur","handleKeyDown","which","up","down","enter","preventDefault","stopPropagation","spinDirection","escape","handleKeyUp","handleIncrementMouseDown","handleDecrementMouseDown","useDebugWarnings","valueIsNumber","labelContent","labelWrapper","__assign","icon","id","htmlFor","root","bottom","spinButtonWrapper","onInput","autoComplete","role","onKeyDown","onKeyUp","arrowButtonsContainer","checked","onMouseDown","onMouseLeave","onMouseUp","tabIndex","displayName","process","env","NODE_ENV","name","mutuallyExclusive"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\SpinButton\\SpinButton.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  KeyCodes,\n  calculatePrecision,\n  classNamesFunction,\n  precisionRound,\n  getNativeProps,\n  getPropsWithDefaults,\n  divProperties,\n} from '../../Utilities';\nimport { getArrowButtonStyles } from './SpinButton.styles';\nimport { KeyboardSpinDirection } from './SpinButton.types';\nimport { Position } from '../../Positioning';\nimport { useAsync, useControllableValue, useWarnings, useId, usePrevious } from '@fluentui/react-hooks';\nimport type { ISpinButtonProps, ISpinButtonStyleProps, ISpinButtonStyles } from './SpinButton.types';\n\ninterface ISpinButtonInternalState {\n  spinningByMouse?: boolean;\n  stepTimeoutHandle: number;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: string | undefined;\n  /** Allows access to the latest `intermediateValue` inside reused callbacks (to avoid stale capture issues) */\n  latestIntermediateValue: string | undefined;\n}\n\nconst getClassNames = classNamesFunction<ISpinButtonStyleProps, ISpinButtonStyles>();\n\nconst COMPONENT_NAME = 'SpinButton';\nconst DEFAULT_PROPS: Required<\n  Pick<\n    ISpinButtonProps,\n    // These are explicitly specified so that only the things which actually have defaults\n    // get marked as required in ISpinButtonPropsWithDefaults below\n    'disabled' | 'label' | 'step' | 'labelPosition' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n> = {\n  disabled: false,\n  label: '',\n  step: 1,\n  labelPosition: Position.start,\n  incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n  decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n};\ntype ISpinButtonPropsWithDefaults = ISpinButtonProps & typeof DEFAULT_PROPS;\n\nconst INITIAL_STEP_DELAY = 400;\nconst STEP_DELAY = 75;\n\nconst useComponentRef = (\n  props: ISpinButtonProps,\n  input: React.RefObject<HTMLDivElement>,\n  value: string | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      focus() {\n        if (input.current) {\n          input.current.focus();\n        }\n      },\n    }),\n    [input, value],\n  );\n};\n\nconst noOp = (): void => {\n  /**\n   * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n   * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n   * The no-op onChange handler was still needed because React gives console errors if an input\n   * doesn't have onChange.\n   *\n   * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n   * ours or 3rd-party, which simulate entering text in a SpinButton)\n   */\n};\n\n/** Clamp the value to the provided min and/or max */\nconst clampValue = (value: number, { min, max }: { max?: number; min?: number }) => {\n  if (typeof max === 'number') {\n    value = Math.min(value, max);\n  }\n  if (typeof min === 'number') {\n    value = Math.max(value, min);\n  }\n  return value;\n};\n\nexport const SpinButtonBase: React.FunctionComponent<ISpinButtonProps> = React.forwardRef<\n  HTMLDivElement,\n  ISpinButtonProps\n>((propsWithoutDefaults, ref) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults) as ISpinButtonPropsWithDefaults;\n  const {\n    disabled,\n    label,\n    min,\n    max,\n    step,\n    defaultValue,\n    value: valueFromProps,\n    precision: precisionFromProps,\n    labelPosition,\n    iconProps,\n    incrementButtonIcon,\n    incrementButtonAriaLabel,\n    decrementButtonIcon,\n    decrementButtonAriaLabel,\n    ariaLabel,\n    ariaDescribedBy,\n    upArrowButtonStyles: customUpArrowButtonStyles,\n    downArrowButtonStyles: customDownArrowButtonStyles,\n    theme,\n    ariaPositionInSet,\n    ariaSetSize,\n    ariaValueNow,\n    ariaValueText,\n    className,\n    inputProps,\n    onDecrement,\n    onIncrement,\n    iconButtonProps,\n    onValidate,\n    onChange,\n    styles,\n  } = props;\n\n  const input = React.useRef<HTMLInputElement>(null);\n  const inputId = useId('input');\n  const labelId = useId('Label');\n\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [keyboardSpinDirection, setKeyboardSpinDirection] = React.useState(KeyboardSpinDirection.notSpinning);\n  const async = useAsync();\n\n  const precision = React.useMemo(() => {\n    return precisionFromProps ?? Math.max(calculatePrecision(step), 0);\n  }, [precisionFromProps, step]);\n\n  /**\n   * Actual current value. If `props.value` is provided (controlled), it will always be used.\n   * If not (uncontrolled), this tracks the current value based on user modifications.\n   * Note that while the user is editing text in the field, this will not be updated until \"commit\"\n   * (blur or press enter).\n   */\n  const [value, setValue] = useControllableValue(valueFromProps, defaultValue ?? String(min || 0), onChange);\n  /**\n   * \"Uncommitted\" internal value while the user is editing text in the field. This lets us wait to\n   * call `onChange` (and possibly update the real value) until the user \"commits\" the value by\n   * pressing enter or blurring the field.\n   */\n  const [intermediateValue, setIntermediateValue] = React.useState<string>();\n\n  const { current: internalState } = React.useRef<ISpinButtonInternalState>({\n    stepTimeoutHandle: -1,\n    latestValue: undefined,\n    latestIntermediateValue: undefined,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestIntermediateValue = intermediateValue;\n\n  const previousValueFromProps = usePrevious(valueFromProps);\n  React.useEffect(() => {\n    // If props.value changes while editing, clear the intermediate value\n    if (valueFromProps !== previousValueFromProps && intermediateValue !== undefined) {\n      setIntermediateValue(undefined);\n    }\n  }, [valueFromProps, previousValueFromProps, intermediateValue]);\n\n  const classNames = getClassNames(styles, {\n    theme: theme!,\n    disabled,\n    isFocused,\n    keyboardSpinDirection,\n    labelPosition,\n    className,\n  });\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, [\n    'onBlur',\n    'onFocus',\n    'className',\n    'onChange',\n  ]);\n\n  /** Validate (commit) function called on blur or enter keypress. */\n  const validate = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLElement>): void => {\n      // Only run validation if the value changed\n      const enteredValue = internalState.latestIntermediateValue;\n      if (enteredValue !== undefined && enteredValue !== internalState.latestValue) {\n        let newValue: string | undefined;\n        if (onValidate) {\n          newValue = onValidate(enteredValue, ev) as string | undefined;\n        } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {\n          // default validation handling\n          newValue = String(clampValue(Number(enteredValue), { min, max }));\n        }\n        if (newValue !== undefined && newValue !== internalState.latestValue) {\n          // Commit the value if it changed\n          setValue(newValue, ev);\n        }\n      }\n\n      // Done validating, so clear the intermediate typed value (if any)\n      setIntermediateValue(undefined);\n    },\n    [internalState, max, min, onValidate, setValue],\n  );\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  const stop = React.useCallback((): void => {\n    if (internalState.stepTimeoutHandle >= 0) {\n      async.clearTimeout(internalState.stepTimeoutHandle);\n      internalState.stepTimeoutHandle = -1;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      internalState.spinningByMouse = false;\n      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);\n    }\n  }, [internalState, keyboardSpinDirection, async]);\n\n  /**\n   * Update the value with the given stepFunction.\n   * Also starts spinning for mousedown events by scheduling another update with setTimeout.\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  const updateValue = React.useCallback(\n    (\n      stepFunction: Required<ISpinButtonProps>['onIncrement'],\n      ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLInputElement>,\n    ): void => {\n      ev.persist();\n\n      if (internalState.latestIntermediateValue !== undefined) {\n        // Edge case: if intermediateValue is set, this means that the user was editing the input\n        // text and then started spinning (either with mouse or keyboard). We need to validate and\n        // call onChange before starting to spin.\n        if (ev.type === 'keydown') {\n          // For the arrow keys, we have to manually trigger validation.\n          // (For the buttons, validation will happen automatically since the input's onBlur will\n          // be triggered after mousedown on the button completes.)\n          validate(ev);\n        }\n        async.requestAnimationFrame(() => {\n          // After handling any value updates, do the spinning update\n          updateValue(stepFunction, ev);\n        });\n        return;\n      }\n\n      // Call the step function and update the value.\n      // (Note: we access the latest value via internalState (not directly) to ensure we don't use\n      // a stale captured value. This is mainly important for spinning by mouse, where we trigger\n      // additional calls to the original updateValue function via setTimeout. It also lets us\n      // avoid useCallback deps on frequently changing values.)\n      const newValue = stepFunction(internalState.latestValue || '', ev) as string | undefined;\n      if (newValue !== undefined && newValue !== internalState.latestValue) {\n        setValue(newValue, ev);\n      }\n\n      // Schedule the next spin if applicable\n      // (will be canceled if there's a mouseup before the timeout runs)\n      const wasSpinning = internalState.spinningByMouse;\n      internalState.spinningByMouse = ev.type === 'mousedown';\n      if (internalState.spinningByMouse) {\n        internalState.stepTimeoutHandle = async.setTimeout(\n          () => {\n            updateValue(stepFunction, ev);\n          },\n          wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY, // the first step is slower\n        );\n      }\n    },\n    [internalState, async, validate, setValue],\n  );\n\n  /** Composed increment handler (uses `props.onIncrement` or default) */\n  const handleIncrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onIncrement) {\n        return onIncrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) + Number(step), { max });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, max, onIncrement, step],\n  );\n\n  /** Composed decrement handler (uses `props.onDecrement` or default) */\n  const handleDecrement = React.useCallback(\n    (newValue: string): string | void => {\n      if (onDecrement) {\n        return onDecrement(newValue);\n      } else {\n        let numericValue = clampValue(Number(newValue) - Number(step), { min });\n        numericValue = precisionRound(numericValue, precision);\n        return String(numericValue);\n      }\n    },\n    [precision, min, onDecrement, step],\n  );\n\n  /** Handles when the user types in the input */\n  const handleInputChange = (ev: React.FormEvent<HTMLInputElement>): void => {\n    setIntermediateValue((ev.target as HTMLInputElement).value);\n  };\n\n  /** Composed focus handler (does internal stuff and calls `props.onFocus`) */\n  const handleFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!input.current) {\n      return;\n    }\n    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      stop();\n    }\n    input.current.select();\n    setIsFocused(true);\n    props.onFocus?.(ev);\n  };\n\n  /** Composed blur handler (does internal stuff and calls `props.onBlur`) */\n  const handleBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    validate(ev);\n    setIsFocused(false);\n    props.onBlur?.(ev);\n  };\n\n  /** Update value when arrow keys are pressed, commit on enter, or revert on escape */\n  const handleKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    // eslint-disable-next-line deprecation/deprecation\n    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    if (disabled) {\n      stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    // eslint-disable-next-line deprecation/deprecation\n    switch (ev.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        updateValue(handleIncrement, ev);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        updateValue(handleDecrement, ev);\n        break;\n      case KeyCodes.enter:\n        // Commit the edited value\n        validate(ev);\n        break;\n      case KeyCodes.escape:\n        // Revert to previous value\n        setIntermediateValue(undefined);\n        break;\n    }\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (keyboardSpinDirection !== spinDirection) {\n      setKeyboardSpinDirection(spinDirection);\n    }\n  };\n\n  /** Stop spinning on keyUp if the up or down arrow key fired this event */\n  const handleKeyUp = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLElement>): void => {\n      // eslint-disable-next-line deprecation/deprecation\n      if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {\n        stop();\n        return;\n      }\n    },\n    [disabled, stop],\n  );\n\n  const handleIncrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleIncrement, ev);\n    },\n    [handleIncrement, updateValue],\n  );\n\n  const handleDecrementMouseDown = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>): void => {\n      updateValue(handleDecrement, ev);\n    },\n    [handleDecrement, updateValue],\n  );\n\n  useComponentRef(props, input, value);\n  useDebugWarnings(props);\n\n  const valueIsNumber = !!value && !isNaN(Number(value)); // Number('') is 0 which may not be desirable\n\n  const labelContent = (iconProps || label) && (\n    <div className={classNames.labelWrapper}>\n      {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n      {label && (\n        <Label id={labelId} htmlFor={inputId} className={classNames.label} disabled={disabled}>\n          {label}\n        </Label>\n      )}\n    </div>\n  );\n\n  return (\n    <div className={classNames.root} ref={ref}>\n      {labelPosition !== Position.bottom && labelContent}\n      <div\n        {...nativeProps}\n        className={classNames.spinButtonWrapper}\n        aria-label={ariaLabel && ariaLabel}\n        aria-posinset={ariaPositionInSet}\n        aria-setsize={ariaSetSize}\n        data-ktp-target={true}\n      >\n        <input\n          // Display intermediateValue while editing the text (before commit)\n          value={intermediateValue ?? value}\n          id={inputId}\n          onChange={noOp}\n          onInput={handleInputChange}\n          className={classNames.input}\n          type=\"text\"\n          autoComplete=\"off\"\n          role=\"spinbutton\"\n          aria-labelledby={label && labelId}\n          // TODO: test what happens while editing\n          aria-valuenow={ariaValueNow ?? (valueIsNumber ? Number(value) : undefined)}\n          aria-valuetext={ariaValueText ?? (valueIsNumber ? undefined : value)}\n          aria-valuemin={min}\n          aria-valuemax={max}\n          aria-describedby={ariaDescribedBy}\n          onBlur={handleBlur}\n          ref={input}\n          onFocus={handleFocus}\n          onKeyDown={handleKeyDown}\n          onKeyUp={handleKeyUp}\n          disabled={disabled}\n          aria-disabled={disabled}\n          data-lpignore\n          data-ktp-execute-target={true}\n          {...inputProps}\n        />\n        <span className={classNames.arrowButtonsContainer}>\n          <IconButton\n            styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n            className={'ms-UpButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n            disabled={disabled}\n            iconProps={incrementButtonIcon}\n            onMouseDown={handleIncrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={incrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n          <IconButton\n            styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n            className={'ms-DownButton'}\n            checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n            disabled={disabled}\n            iconProps={decrementButtonIcon}\n            onMouseDown={handleDecrementMouseDown}\n            onMouseLeave={stop}\n            onMouseUp={stop}\n            tabIndex={-1}\n            ariaLabel={decrementButtonAriaLabel}\n            data-is-focusable={false}\n            {...iconButtonProps}\n          />\n        </span>\n      </div>\n      {labelPosition === Position.bottom && labelContent}\n    </div>\n  );\n});\nSpinButtonBase.displayName = COMPONENT_NAME;\n\nconst useDebugWarnings = (props: ISpinButtonProps) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { value: 'defaultValue' },\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}
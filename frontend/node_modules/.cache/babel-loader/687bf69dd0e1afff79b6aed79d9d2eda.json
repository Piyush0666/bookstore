{"ast":null,"code":"import { getWindow } from '@fluentui/utilities';\n/**\n * Wrapper for ResizeObserver, with fallback for browsers that don't support ResizeObserver.\n *\n * Calls the onResize callback once layout is complete, and again whenever any of the target(s) change size.\n * Or if ResizeObserver isn't supported, calls the callback whenever the window changes size.\n *\n * @param target - Either a single element, or array of elements to watch for size changes.\n * @param onResize - Callback to be notified when layout is complete, and when the target(s) change size.\n *    If this browser supports ResizeObserver, the callback will be passed the ResizeObserverEntry[] array.\n *    Otherwise, the entries array will be undefined, and you'll need to find another way to get the element's size,\n *    (e.g. clientWidth/clientHeight or getBoundingClientRect).\n *\n * @returns A function to clean up the observer/listener.\n */\n\nexport var observeResize = function (target, onResize) {\n  if (typeof ResizeObserver !== 'undefined') {\n    var observer_1 = new ResizeObserver(onResize);\n\n    if (Array.isArray(target)) {\n      target.forEach(function (t) {\n        return observer_1.observe(t);\n      });\n    } else {\n      observer_1.observe(target);\n    }\n\n    return function () {\n      return observer_1.disconnect();\n    };\n  } else {\n    // Fallback for browsers that don't support ResizeObserver\n    var onResizeWrapper_1 = function () {\n      return onResize(undefined);\n    };\n\n    var win_1 = getWindow(Array.isArray(target) ? target[0] : target);\n\n    if (!win_1) {\n      // Can't listen for resize if we can't get the window object\n      return function () {// Nothing to clean up\n      };\n    } // Listen for the first animation frame, which will happen after layout is complete\n\n\n    var animationFrameId_1 = win_1.requestAnimationFrame(onResizeWrapper_1);\n    win_1.addEventListener('resize', onResizeWrapper_1, false);\n    return function () {\n      win_1.cancelAnimationFrame(animationFrameId_1);\n      win_1.removeEventListener('resize', onResizeWrapper_1, false);\n    };\n  }\n};","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,qBAA1B;AAEA;;;;;;;;;;;;;;;AAcA,OAAO,IAAMC,aAAa,GAAG,UAC3BC,MAD2B,EAE3BC,QAF2B,EAE4C;EAEvE,IAAI,OAAOC,cAAP,KAA0B,WAA9B,EAA2C;IACzC,IAAMC,UAAQ,GAAG,IAAID,cAAJ,CAAmBD,QAAnB,CAAjB;;IAEA,IAAIG,KAAK,CAACC,OAAN,CAAcL,MAAd,CAAJ,EAA2B;MACzBA,MAAM,CAACM,OAAP,CAAe,aAAC;QAAI,iBAAQ,CAACC,OAAT,CAAiBC,CAAjB;MAAmB,CAAvC;IACD,CAFD,MAEO;MACLL,UAAQ,CAACI,OAAT,CAAiBP,MAAjB;IACD;;IAED,OAAO;MAAM,iBAAQ,CAACS,UAAT;IAAqB,CAAlC;EACD,CAVD,MAUO;IACL;IACA,IAAMC,iBAAe,GAAG;MAAM,eAAQ,CAACC,SAAD,CAAR;IAAmB,CAAjD;;IAEA,IAAMC,KAAG,GAAGd,SAAS,CAACM,KAAK,CAACC,OAAN,CAAcL,MAAd,IAAwBA,MAAM,CAAC,CAAD,CAA9B,GAAoCA,MAArC,CAArB;;IACA,IAAI,CAACY,KAAL,EAAU;MACR;MACA,OAAO,aACL;MACD,CAFD;IAGD,CAVI,CAYL;;;IACA,IAAMC,kBAAgB,GAAGD,KAAG,CAACE,qBAAJ,CAA0BJ,iBAA1B,CAAzB;IACAE,KAAG,CAACG,gBAAJ,CAAqB,QAArB,EAA+BL,iBAA/B,EAAgD,KAAhD;IAEA,OAAO;MACLE,KAAG,CAACI,oBAAJ,CAAyBH,kBAAzB;MACAD,KAAG,CAACK,mBAAJ,CAAwB,QAAxB,EAAkCP,iBAAlC,EAAmD,KAAnD;IACD,CAHD;EAID;AACF,CAnCM","names":["getWindow","observeResize","target","onResize","ResizeObserver","observer_1","Array","isArray","forEach","observe","t","disconnect","onResizeWrapper_1","undefined","win_1","animationFrameId_1","requestAnimationFrame","addEventListener","cancelAnimationFrame","removeEventListener"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\src\\utilities\\observeResize.ts"],"sourcesContent":["import { getWindow } from '@fluentui/utilities';\n\n/**\n * Wrapper for ResizeObserver, with fallback for browsers that don't support ResizeObserver.\n *\n * Calls the onResize callback once layout is complete, and again whenever any of the target(s) change size.\n * Or if ResizeObserver isn't supported, calls the callback whenever the window changes size.\n *\n * @param target - Either a single element, or array of elements to watch for size changes.\n * @param onResize - Callback to be notified when layout is complete, and when the target(s) change size.\n *    If this browser supports ResizeObserver, the callback will be passed the ResizeObserverEntry[] array.\n *    Otherwise, the entries array will be undefined, and you'll need to find another way to get the element's size,\n *    (e.g. clientWidth/clientHeight or getBoundingClientRect).\n *\n * @returns A function to clean up the observer/listener.\n */\nexport const observeResize = (\n  target: Element | Element[],\n  onResize: (entries: readonly ResizeObserverEntry[] | undefined) => void,\n): (() => void) => {\n  if (typeof ResizeObserver !== 'undefined') {\n    const observer = new ResizeObserver(onResize);\n\n    if (Array.isArray(target)) {\n      target.forEach(t => observer.observe(t));\n    } else {\n      observer.observe(target);\n    }\n\n    return () => observer.disconnect();\n  } else {\n    // Fallback for browsers that don't support ResizeObserver\n    const onResizeWrapper = () => onResize(undefined);\n\n    const win = getWindow(Array.isArray(target) ? target[0] : target);\n    if (!win) {\n      // Can't listen for resize if we can't get the window object\n      return () => {\n        // Nothing to clean up\n      };\n    }\n\n    // Listen for the first animation frame, which will happen after layout is complete\n    const animationFrameId = win.requestAnimationFrame(onResizeWrapper);\n    win.addEventListener('resize', onResizeWrapper, false);\n\n    return () => {\n      win.cancelAnimationFrame(animationFrameId);\n      win.removeEventListener('resize', onResizeWrapper, false);\n    };\n  }\n};\n\n/** Temporary type definition for ResizeObserver. Can be removed when official types are available. */\ntype ResizeObserver = {\n  new (callback: (entries: readonly ResizeObserverEntry[], observer: ResizeObserver) => void): ResizeObserver;\n  observe(target: Element, options?: { box: 'content-box' | 'border-box' }): void;\n  unobserve(target: Element): void;\n  disconnect(): void;\n};\n\n/** Temporary type definition for ResizeObserverEntry. Can be removed when official types are available. */\ntype ResizeObserverEntry = {\n  readonly contentRect: DOMRectReadOnly;\n  readonly target: Element;\n};\n\n/** Temporary definition for ResizeObserver. Can be removed when official types are available. */\ndeclare const ResizeObserver: ResizeObserver | undefined;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props: props,\n      mutuallyExclusive: {\n        focusOnHover: 'onHover',\n        selectedId: 'defaultSelectedId'\n      },\n      deprecations: {\n        isControlled: \"selectedId' or 'defaultSelectedId\",\n        onColorChanged: 'onChange'\n      }\n    });\n  }\n}\n\nexport var SwatchColorPickerBase = React.forwardRef(function (props, ref) {\n  var defaultId = useId('swatchColorPicker');\n  var id = props.id || defaultId;\n  var internalState = useConst({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250\n  });\n\n  var _a = useSetTimeout(),\n      setTimeout = _a.setTimeout,\n      clearTimeout = _a.clearTimeout;\n\n  useDebugWarnings(props);\n  var colorCells = props.colorCells,\n      _b = props.cellShape,\n      cellShape = _b === void 0 ? 'circle' : _b,\n      columnCount = props.columnCount,\n      _c = props.shouldFocusCircularNavigate,\n      shouldFocusCircularNavigate = _c === void 0 ? true : _c,\n      className = props.className,\n      _d = props.disabled,\n      disabled = _d === void 0 ? false : _d,\n      doNotContainWithinFocusZone = props.doNotContainWithinFocusZone,\n      styles = props.styles,\n      _e = props.cellMargin,\n      cellMargin = _e === void 0 ? 10 : _e,\n      defaultSelectedId = props.defaultSelectedId,\n      focusOnHover = props.focusOnHover,\n      mouseLeaveParentSelector = props.mouseLeaveParentSelector,\n      onChange = props.onChange,\n      // eslint-disable-next-line deprecation/deprecation\n  onColorChanged = props.onColorChanged,\n      onCellHovered = props.onCellHovered,\n      onCellFocused = props.onCellFocused,\n      getColorGridCellStyles = props.getColorGridCellStyles,\n      cellHeight = props.cellHeight,\n      cellWidth = props.cellWidth,\n      cellBorderWidth = props.cellBorderWidth;\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n\n  var itemsWithIndex = React.useMemo(function () {\n    return colorCells.map(function (item, index) {\n      return __assign(__assign({}, item), {\n        index: index\n      });\n    });\n  }, [colorCells]);\n  var mergedOnChange = React.useCallback(function (ev, newSelectedId) {\n    var _a; // Call both new and old change handlers, and add the extra `color` parameter\n\n\n    var newColor = (_a = colorCells.filter(function (c) {\n      return c.id === newSelectedId;\n    })[0]) === null || _a === void 0 ? void 0 : _a.color;\n    onChange === null || onChange === void 0 ? void 0 : onChange(ev, newSelectedId, newColor);\n    onColorChanged === null || onColorChanged === void 0 ? void 0 : onColorChanged(newSelectedId, newColor);\n  }, [onChange, onColorChanged, colorCells]);\n\n  var _f = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange),\n      selectedId = _f[0],\n      setSelectedId = _f[1];\n\n  var classNames = getClassNames(styles, {\n    theme: props.theme,\n    className: className,\n    cellMargin: cellMargin\n  });\n  var gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer\n  };\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n\n  var isSemanticRadio = colorCells.length <= columnCount;\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n\n  var onSwatchColorPickerBlur = React.useCallback(function (event) {\n    if (onCellFocused) {\n      internalState.cellFocused = false;\n      onCellFocused(undefined, undefined, event);\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n\n  var onMouseEnter = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    if (internalState.isNavigationIdle && !disabled) {\n      ev.currentTarget.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseMove = React.useCallback(function (ev) {\n    if (!focusOnHover) {\n      return !internalState.isNavigationIdle || !!disabled;\n    }\n\n    var targetElement = ev.currentTarget; // If navigation is idle and the targetElement is the focused element bail out\n\n    if (internalState.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n      targetElement.focus();\n    }\n\n    return true;\n  }, [focusOnHover, internalState, disabled]);\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n\n  var onMouseLeave = React.useCallback(function (ev) {\n    var parentSelector = mouseLeaveParentSelector;\n\n    if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n      return;\n    } // Get the elements that math the given selector\n\n\n    var elements = document.querySelectorAll(parentSelector); // iterate over the elements return to make sure it is a parent of the target and focus it\n\n    for (var index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if (elements[index].setActive) {\n          try {\n            elements[index].setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          elements[index].focus();\n        }\n\n        break;\n      }\n    }\n  }, [disabled, focusOnHover, internalState, mouseLeaveParentSelector]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n\n  var onGridCellHovered = React.useCallback(function (item, event) {\n    if (onCellHovered) {\n      item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n    }\n  }, [onCellHovered]);\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n\n  var onGridCellFocused = React.useCallback(function (item, event) {\n    if (onCellFocused) {\n      if (item) {\n        internalState.cellFocused = true;\n        return onCellFocused(item.id, item.color, event);\n      } else {\n        internalState.cellFocused = false;\n        return onCellFocused(undefined, undefined, event);\n      }\n    }\n  }, [internalState, onCellFocused]);\n  /**\n   * Handle the click on a cell\n   */\n\n  var onCellClick = React.useCallback(function (item, event) {\n    if (disabled) {\n      return;\n    }\n\n    if (item.id !== selectedId) {\n      if (onCellFocused && internalState.cellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n\n      setSelectedId(item.id, event);\n    }\n  }, [disabled, internalState, onCellFocused, selectedId, setSelectedId]);\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n\n  var setNavigationTimeout = React.useCallback(function () {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(function () {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n  /**\n   * Callback used to handle KeyCode events\n   */\n\n  var onKeyDown = React.useCallback(function (ev) {\n    if ( // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.up || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.down || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.left || // eslint-disable-next-line deprecation/deprecation\n    ev.which === KeyCodes.right) {\n      setNavigationTimeout();\n    }\n  }, [setNavigationTimeout]);\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n\n  var renderOption = function (item) {\n    return React.createElement(ColorPickerGridCell, {\n      item: item,\n      idPrefix: id,\n      color: item.color,\n      styles: getColorGridCellStyles,\n      disabled: disabled,\n      onClick: onCellClick,\n      onHover: onGridCellHovered,\n      onFocus: onGridCellFocused,\n      selected: selectedId === item.id,\n      circle: cellShape === 'circle',\n      label: item.label,\n      onMouseEnter: onMouseEnter,\n      onMouseMove: onMouseMove,\n      onMouseLeave: onMouseLeave,\n      onWheel: setNavigationTimeout,\n      onKeyDown: onKeyDown,\n      height: cellHeight,\n      width: cellWidth,\n      borderWidth: cellBorderWidth,\n      isRadio: isSemanticRadio\n    });\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  var onRenderItem = function (item, index) {\n    var _a = props.onRenderColorCell,\n        onRenderColorCell = _a === void 0 ? renderOption : _a;\n    return onRenderColorCell(item, renderOption);\n  };\n\n  return React.createElement(ButtonGrid, __assign({}, props, {\n    ref: ref,\n    id: id,\n    items: itemsWithIndex,\n    columnCount: columnCount,\n    isSemanticRadio: isSemanticRadio,\n    // eslint-disable-next-line react/jsx-no-bind\n    onRenderItem: onRenderItem,\n    shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n    doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n    onBlur: onSwatchColorPickerBlur,\n    theme: props.theme,\n    styles: gridStyles\n  }));\n});\nSwatchColorPickerBase.displayName = COMPONENT_NAME;","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,kBAAT,EAA6BC,QAA7B,QAA6C,iBAA7C;AACA,SAASC,UAAT,QAA2B,uCAA3B;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,KAAT,EAAgBC,QAAhB,EAA0BC,aAA1B,EAAyCC,oBAAzC,EAA+DC,WAA/D,QAAkF,uBAAlF;AAgBA,IAAMC,aAAa,GAAGT,kBAAkB,EAAxC;AAEA,IAAMU,cAAc,GAAG,mBAAvB;;AAEA,SAASC,gBAAT,CAA0BC,KAA1B,EAAwD;EACtD,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACAP,WAAW,CAAC;MACVQ,IAAI,EAAEN,cADI;MAEVE,KAAK,OAFK;MAGVK,iBAAiB,EAAE;QAAEC,YAAY,EAAE,SAAhB;QAA2BC,UAAU,EAAE;MAAvC,CAHT;MAIVC,YAAY,EAAE;QAAEC,YAAY,EAAE,mCAAhB;QAAqDC,cAAc,EAAE;MAArE;IAJJ,CAAD,CAAX;EAMD;AACF;;AAED,OAAO,IAAMC,qBAAqB,GAAqDxB,KAAK,CAACyB,UAAN,CAGrF,UAACZ,KAAD,EAAQa,GAAR,EAAW;EACX,IAAMC,SAAS,GAAGtB,KAAK,CAAC,mBAAD,CAAvB;EACA,IAAMuB,EAAE,GAAGf,KAAK,CAACe,EAAN,IAAYD,SAAvB;EAEA,IAAME,aAAa,GAAGvB,QAAQ,CAAkC;IAC9DwB,gBAAgB,EAAE,IAD4C;IAE9DC,WAAW,EAAE,KAFiD;IAG9DC,uBAAuB,EAAEC,SAHqC;IAI9DC,mBAAmB,EAAE;EAJyC,CAAlC,CAA9B;;EAOM,SAA+B3B,aAAa,EAA5C;EAAA,IAAE4B,UAAU,gBAAZ;EAAA,IAAcC,YAAY,kBAA1B;;EAENxB,gBAAgB,CAACC,KAAD,CAAhB;EAGE,cAAU,GAqBRA,KAAK,WArBP;EAAA,IACAwB,KAoBExB,KAAK,UArBP;EAAA,IACAyB,SAAS,mBAAG,QAAH,GAAWD,EADpB;EAAA,IAEAE,WAAW,GAmBT1B,KAAK,YArBP;EAAA,IAGA2B,KAkBE3B,KAAK,4BArBP;EAAA,IAGA4B,2BAA2B,mBAAG,IAAH,GAAOD,EAHlC;EAAA,IAIAE,SAAS,GAiBP7B,KAAK,UArBP;EAAA,IAKA8B,KAgBE9B,KAAK,SArBP;EAAA,IAKA+B,QAAQ,mBAAG,KAAH,GAAQD,EALhB;EAAA,IAMAE,2BAA2B,GAezBhC,KAAK,4BArBP;EAAA,IAOAiC,MAAM,GAcJjC,KAAK,OArBP;EAAA,IAQAkC,KAaElC,KAAK,WArBP;EAAA,IAQAmC,UAAU,mBAAG,EAAH,GAAKD,EARf;EAAA,IASAE,iBAAiB,GAYfpC,KAAK,kBArBP;EAAA,IAUAM,YAAY,GAWVN,KAAK,aArBP;EAAA,IAWAqC,wBAAwB,GAUtBrC,KAAK,yBArBP;EAAA,IAYAsC,QAAQ,GASNtC,KAAK,SArBP;EAAA,IAaA;EACAU,cAAc,GAOZV,KAAK,eArBP;EAAA,IAeAuC,aAAa,GAMXvC,KAAK,cArBP;EAAA,IAgBAwC,aAAa,GAKXxC,KAAK,cArBP;EAAA,IAiBAyC,sBAAsB,GAIpBzC,KAAK,uBArBP;EAAA,IAkBA0C,UAAU,GAGR1C,KAAK,WArBP;EAAA,IAmBA2C,SAAS,GAEP3C,KAAK,UArBP;EAAA,IAoBA4C,eAAe,GACb5C,KAAK,gBArBP;EAuBF;;;;EAGA,IAAM6C,cAAc,GAAG1D,KAAK,CAAC2D,OAAN,CAAc;IACnC,OAAOC,UAAU,CAACC,GAAX,CAAe,UAACC,IAAD,EAAOC,KAAP,EAAY;MAChC,6BAAYD,IAAZ,GAAgB;QAAEC,KAAK,EAAEA;MAAT,CAAhB;IACD,CAFM,CAAP;EAGD,CAJsB,EAIpB,CAACH,UAAD,CAJoB,CAAvB;EAMA,IAAMI,cAAc,GAAGhE,KAAK,CAACiE,WAAN,CACrB,UAACC,EAAD,EAAmCC,aAAnC,EAAoE;WAAA,CAClE;;;IACA,IAAMC,QAAQ,GAAG,gBAAU,CAACC,MAAX,CAAkB,aAAC;MAAI,QAAC,CAACzC,EAAF,KAASuC,aAAT;IAAsB,CAA7C,EAA+C,CAA/C,OAAiD,IAAjD,IAAiDG,aAAjD,GAAiD,MAAjD,GAAiDA,GAAEC,KAApE;IACApB,QAAQ,SAAR,YAAQ,WAAR,GAAQ,MAAR,WAAQ,CAAGe,EAAH,EAAOC,aAAP,EAAsBC,QAAtB,CAAR;IACA7C,cAAc,SAAd,kBAAc,WAAd,GAAc,MAAd,iBAAc,CAAG4C,aAAH,EAAkBC,QAAlB,CAAd;EACD,CANoB,EAOrB,CAACjB,QAAD,EAAW5B,cAAX,EAA2BqC,UAA3B,CAPqB,CAAvB;;EAUM,SAA8BpD,oBAAoB,CAACK,KAAK,CAACO,UAAP,EAAmB6B,iBAAnB,EAAsCe,cAAtC,CAAlD;EAAA,IAAC5C,UAAU,QAAX;EAAA,IAAaoD,aAAa,QAA1B;;EAEN,IAAMC,UAAU,GAAG/D,aAAa,CAACoC,MAAD,EAAU;IACxC4B,KAAK,EAAE7D,KAAK,CAAC6D,KAD2B;IAExChC,SAAS,WAF+B;IAGxCM,UAAU;EAH8B,CAAV,CAAhC;EAMA,IAAM2B,UAAU,GAAG;IACjBC,IAAI,EAAEH,UAAU,CAACG,IADA;IAEjBC,SAAS,EAAEJ,UAAU,CAACI,SAFL;IAGjBC,gBAAgB,EAAEL,UAAU,CAACK;EAHZ,CAAnB;EAMA;;;;;;;;EAOA,IAAMC,eAAe,GAAGnB,UAAU,CAACoB,MAAX,IAAqBzC,WAA7C;EAEA;;;;;EAIA,IAAM0C,uBAAuB,GAAGjF,KAAK,CAACiE,WAAN,CAC9B,UAACiB,KAAD,EAA4C;IAC1C,IAAI7B,aAAJ,EAAmB;MACjBxB,aAAa,CAACE,WAAd,GAA4B,KAA5B;MACAsB,aAAa,CAACpB,SAAD,EAAYA,SAAZ,EAAuBiD,KAAvB,CAAb;IACD;EACF,CAN6B,EAO9B,CAACrD,aAAD,EAAgBwB,aAAhB,CAP8B,CAAhC;EAUA;;;;EAGA,IAAM8B,YAAY,GAAGnF,KAAK,CAACiE,WAAN,CACnB,UAACC,EAAD,EAAwC;IACtC,IAAI,CAAC/C,YAAL,EAAmB;MACjB,OAAO,CAACU,aAAa,CAACC,gBAAf,IAAmC,CAAC,CAACc,QAA5C;IACD;;IACD,IAAIf,aAAa,CAACC,gBAAd,IAAkC,CAACc,QAAvC,EAAiD;MAC/CsB,EAAE,CAACkB,aAAH,CAAiBC,KAAjB;IACD;;IACD,OAAO,IAAP;EACD,CATkB,EAUnB,CAAClE,YAAD,EAAeU,aAAf,EAA8Be,QAA9B,CAVmB,CAArB;EAaA;;;;EAGA,IAAM0C,WAAW,GAAGtF,KAAK,CAACiE,WAAN,CAClB,UAACC,EAAD,EAAwC;IACtC,IAAI,CAAC/C,YAAL,EAAmB;MACjB,OAAO,CAACU,aAAa,CAACC,gBAAf,IAAmC,CAAC,CAACc,QAA5C;IACD;;IAED,IAAM2C,aAAa,GAAGrB,EAAE,CAACkB,aAAzB,CALsC,CAOtC;;IACA,IAAIvD,aAAa,CAACC,gBAAd,IAAkC,EAAE0D,QAAQ,IAAID,aAAa,KAAMC,QAAQ,CAACC,aAA1C,CAAtC,EAAgH;MAC9GF,aAAa,CAACF,KAAd;IACD;;IAED,OAAO,IAAP;EACD,CAdiB,EAelB,CAAClE,YAAD,EAAeU,aAAf,EAA8Be,QAA9B,CAfkB,CAApB;EAkBA;;;;EAGA,IAAM8C,YAAY,GAAG1F,KAAK,CAACiE,WAAN,CACnB,UAACC,EAAD,EAAwC;IACtC,IAAMyB,cAAc,GAAGzC,wBAAvB;;IAEA,IAAI,CAAC/B,YAAD,IAAiB,CAACwE,cAAlB,IAAoC,CAAC9D,aAAa,CAACC,gBAAnD,IAAuEc,QAA3E,EAAqF;MACnF;IACD,CALqC,CAOtC;;;IACA,IAAMgD,QAAQ,GAAGJ,QAAQ,CAACK,gBAAT,CAA0BF,cAA1B,CAAjB,CARsC,CAUtC;;IACA,KAAK,IAAI5B,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG6B,QAAQ,CAACZ,MAArC,EAA6CjB,KAAK,IAAI,CAAtD,EAAyD;MACvD,IAAI6B,QAAQ,CAAC7B,KAAD,CAAR,CAAgB+B,QAAhB,CAAyB5B,EAAE,CAACkB,aAA5B,CAAJ,EAAgD;QAC9C;;;;;QAKA,IAAKQ,QAAQ,CAAC7B,KAAD,CAAR,CAAwBgC,SAA7B,EAAwC;UACtC,IAAI;YACDH,QAAQ,CAAC7B,KAAD,CAAR,CAAwBgC,SAAxB;UACF,CAFD,CAEE,OAAOC,CAAP,EAAU;YACV;UACD;QACF,CAND,MAMO;UACJJ,QAAQ,CAAC7B,KAAD,CAAR,CAAgCsB,KAAhC;QACF;;QAED;MACD;IACF;EACF,CAhCkB,EAiCnB,CAACzC,QAAD,EAAWzB,YAAX,EAAyBU,aAAzB,EAAwCqB,wBAAxC,CAjCmB,CAArB;EAoCA;;;;;EAIA,IAAM+C,iBAAiB,GAAGjG,KAAK,CAACiE,WAAN,CACxB,UAACH,IAAD,EAAyBoB,KAAzB,EAAoE;IAClE,IAAI9B,aAAJ,EAAmB;MACjBU,IAAI,GAAGV,aAAa,CAACU,IAAI,CAAClC,EAAN,EAAUkC,IAAI,CAACS,KAAf,EAAsBW,KAAtB,CAAhB,GAA+C9B,aAAa,CAACnB,SAAD,EAAYA,SAAZ,EAAuBiD,KAAvB,CAAhE;IACD;EACF,CALuB,EAMxB,CAAC9B,aAAD,CANwB,CAA1B;EASA;;;;EAGA,IAAM8C,iBAAiB,GAAGlG,KAAK,CAACiE,WAAN,CACxB,UAACH,IAAD,EAAyBoB,KAAzB,EAAmE;IACjE,IAAI7B,aAAJ,EAAmB;MACjB,IAAIS,IAAJ,EAAU;QACRjC,aAAa,CAACE,WAAd,GAA4B,IAA5B;QACA,OAAOsB,aAAa,CAACS,IAAI,CAAClC,EAAN,EAAUkC,IAAI,CAACS,KAAf,EAAsBW,KAAtB,CAApB;MACD,CAHD,MAGO;QACLrD,aAAa,CAACE,WAAd,GAA4B,KAA5B;QACA,OAAOsB,aAAa,CAACpB,SAAD,EAAYA,SAAZ,EAAuBiD,KAAvB,CAApB;MACD;IACF;EACF,CAXuB,EAYxB,CAACrD,aAAD,EAAgBwB,aAAhB,CAZwB,CAA1B;EAeA;;;;EAGA,IAAM8C,WAAW,GAAGnG,KAAK,CAACiE,WAAN,CAClB,UAACH,IAAD,EAAwBoB,KAAxB,EAAmE;IACjE,IAAItC,QAAJ,EAAc;MACZ;IACD;;IAED,IAAIkB,IAAI,CAAClC,EAAL,KAAYR,UAAhB,EAA4B;MAC1B,IAAIiC,aAAa,IAAIxB,aAAa,CAACE,WAAnC,EAAgD;QAC9CF,aAAa,CAACE,WAAd,GAA4B,KAA5B;QACAsB,aAAa,CAACpB,SAAD,EAAYA,SAAZ,EAAuBiD,KAAvB,CAAb;MACD;;MACDV,aAAa,CAACV,IAAI,CAAClC,EAAN,EAAUsD,KAAV,CAAb;IACD;EACF,CAbiB,EAclB,CAACtC,QAAD,EAAWf,aAAX,EAA0BwB,aAA1B,EAAyCjC,UAAzC,EAAqDoD,aAArD,CAdkB,CAApB;EAiBA;;;;;EAIA,IAAM4B,oBAAoB,GAAGpG,KAAK,CAACiE,WAAN,CAAkB;IAC7C,IAAI,CAACpC,aAAa,CAACC,gBAAf,IAAmCD,aAAa,CAACG,uBAAd,KAA0CC,SAAjF,EAA4F;MAC1FG,YAAY,CAACP,aAAa,CAACG,uBAAf,CAAZ;MACAH,aAAa,CAACG,uBAAd,GAAwCC,SAAxC;IACD,CAHD,MAGO;MACLJ,aAAa,CAACC,gBAAd,GAAiC,KAAjC;IACD;;IAEDD,aAAa,CAACG,uBAAd,GAAwCG,UAAU,CAAC;MACjDN,aAAa,CAACC,gBAAd,GAAiC,IAAjC;IACD,CAFiD,EAE/CD,aAAa,CAACK,mBAFiC,CAAlD;EAGD,CAX4B,EAW1B,CAACE,YAAD,EAAeP,aAAf,EAA8BM,UAA9B,CAX0B,CAA7B;EAaA;;;;EAGA,IAAMkE,SAAS,GAAGrG,KAAK,CAACiE,WAAN,CAChB,UAACC,EAAD,EAA2C;IACzC,KACE;IACAA,EAAE,CAACoC,KAAH,KAAapG,QAAQ,CAACqG,EAAtB,IACA;IACArC,EAAE,CAACoC,KAAH,KAAapG,QAAQ,CAACsG,IAFtB,IAGA;IACAtC,EAAE,CAACoC,KAAH,KAAapG,QAAQ,CAACuG,IAJtB,IAKA;IACAvC,EAAE,CAACoC,KAAH,KAAapG,QAAQ,CAACwG,KARxB,EASE;MACAN,oBAAoB;IACrB;EACF,CAde,EAehB,CAACA,oBAAD,CAfgB,CAAlB;EAkBA;;;;;;EAKA,IAAMO,YAAY,GAAG,UAAC7C,IAAD,EAAsB;IACzC,OACE9D,oBAACI,mBAAD,EAAoB;MAClB0D,IAAI,EAAEA,IADY;MAElB8C,QAAQ,EAAEhF,EAFQ;MAGlB2C,KAAK,EAAET,IAAI,CAACS,KAHM;MAIlBzB,MAAM,EAAEQ,sBAJU;MAKlBV,QAAQ,EAAEA,QALQ;MAMlBiE,OAAO,EAAEV,WANS;MAOlBW,OAAO,EAAEb,iBAPS;MAQlBc,OAAO,EAAEb,iBARS;MASlBc,QAAQ,EAAE5F,UAAU,KAAK0C,IAAI,CAAClC,EATZ;MAUlBqF,MAAM,EAAE3E,SAAS,KAAK,QAVJ;MAWlB4E,KAAK,EAAEpD,IAAI,CAACoD,KAXM;MAYlB/B,YAAY,EAAEA,YAZI;MAalBG,WAAW,EAAEA,WAbK;MAclBI,YAAY,EAAEA,YAdI;MAelByB,OAAO,EAAEf,oBAfS;MAgBlBC,SAAS,EAAEA,SAhBO;MAiBlBe,MAAM,EAAE7D,UAjBU;MAkBlB8D,KAAK,EAAE7D,SAlBW;MAmBlB8D,WAAW,EAAE7D,eAnBK;MAoBlB8D,OAAO,EAAExC;IApBS,CAApB,CADF;EAwBD,CAzBD;;EA2BA,IAAInB,UAAU,CAACoB,MAAX,GAAoB,CAApB,IAAyBzC,WAAW,GAAG,CAA3C,EAA8C;IAC5C,OAAO,IAAP;EACD;;EAED,IAAMiF,YAAY,GAAG,UAAC1D,IAAD,EAAwBC,KAAxB,EAAqC;IAChD,SAAqClD,KAAK,kBAA1C;IAAA,qBAAiB,mBAAG8F,YAAH,GAAerC,EAAhC;IACR,OAAOmD,iBAAiB,CAAC3D,IAAD,EAAO6C,YAAP,CAAxB;EACD,CAHD;;EAIA,OACE3G,oBAACG,UAAD,EAAWuH,aACH7G,KADG,EACmC;IAC5Ca,GAAG,EAAEA,GADuC;IAE5CE,EAAE,EAAEA,EAFwC;IAG5C+F,KAAK,EAAEjE,cAHqC;IAI5CnB,WAAW,EAAEA,WAJ+B;IAK5CwC,eAAe,EAAEA,eAL2B;IAM5C;IACAyC,YAAY,EAAEA,YAP8B;IAQ5C/E,2BAA2B,EAAEA,2BARe;IAS5CI,2BAA2B,EAAEA,2BATe;IAU5C+E,MAAM,EAAE3C,uBAVoC;IAW5CP,KAAK,EAAE7D,KAAK,CAAC6D,KAX+B;IAY5C5B,MAAM,EAAE6B;EAZoC,CADnC,CAAX,CADF;AAiBD,CAhUsF,CAAhF;AAkUPnD,qBAAqB,CAACqG,WAAtB,GAAoClH,cAApC","names":["React","classNamesFunction","KeyCodes","ButtonGrid","ColorPickerGridCell","useId","useConst","useSetTimeout","useControllableValue","useWarnings","getClassNames","COMPONENT_NAME","useDebugWarnings","props","process","env","NODE_ENV","name","mutuallyExclusive","focusOnHover","selectedId","deprecations","isControlled","onColorChanged","SwatchColorPickerBase","forwardRef","ref","defaultId","id","internalState","isNavigationIdle","cellFocused","navigationIdleTimeoutId","undefined","navigationIdleDelay","setTimeout","clearTimeout","_b","cellShape","columnCount","_c","shouldFocusCircularNavigate","className","_d","disabled","doNotContainWithinFocusZone","styles","_e","cellMargin","defaultSelectedId","mouseLeaveParentSelector","onChange","onCellHovered","onCellFocused","getColorGridCellStyles","cellHeight","cellWidth","cellBorderWidth","itemsWithIndex","useMemo","colorCells","map","item","index","mergedOnChange","useCallback","ev","newSelectedId","newColor","filter","_a","color","setSelectedId","classNames","theme","gridStyles","root","tableCell","focusedContainer","isSemanticRadio","length","onSwatchColorPickerBlur","event","onMouseEnter","currentTarget","focus","onMouseMove","targetElement","document","activeElement","onMouseLeave","parentSelector","elements","querySelectorAll","contains","setActive","e","onGridCellHovered","onGridCellFocused","onCellClick","setNavigationTimeout","onKeyDown","which","up","down","left","right","renderOption","idPrefix","onClick","onHover","onFocus","selected","circle","label","onWheel","height","width","borderWidth","isRadio","onRenderItem","onRenderColorCell","__assign","items","onBlur","displayName"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\SwatchColorPicker\\SwatchColorPicker.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, KeyCodes } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { useId, useConst, useSetTimeout, useControllableValue, useWarnings } from '@fluentui/react-hooks';\nimport type {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport type { IColorCellProps } from './ColorPickerGridCell.types';\nimport type { IButtonGridProps } from '../../utilities/ButtonGrid/ButtonGrid.types';\n\ninterface ISwatchColorPickerInternalState {\n  isNavigationIdle: boolean;\n  cellFocused: boolean;\n  navigationIdleTimeoutId: number | undefined;\n  navigationIdleDelay: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nfunction useDebugWarnings(props: ISwatchColorPickerProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      mutuallyExclusive: { focusOnHover: 'onHover', selectedId: 'defaultSelectedId' },\n      deprecations: { isControlled: \"selectedId' or 'defaultSelectedId\", onColorChanged: 'onChange' },\n    });\n  }\n}\n\nexport const SwatchColorPickerBase: React.FunctionComponent<ISwatchColorPickerProps> = React.forwardRef<\n  HTMLElement,\n  ISwatchColorPickerProps\n>((props, ref) => {\n  const defaultId = useId('swatchColorPicker');\n  const id = props.id || defaultId;\n\n  const internalState = useConst<ISwatchColorPickerInternalState>({\n    isNavigationIdle: true,\n    cellFocused: false,\n    navigationIdleTimeoutId: undefined,\n    navigationIdleDelay: 250,\n  });\n\n  const { setTimeout, clearTimeout } = useSetTimeout();\n\n  useDebugWarnings(props);\n\n  const {\n    colorCells,\n    cellShape = 'circle',\n    columnCount,\n    shouldFocusCircularNavigate = true,\n    className,\n    disabled = false,\n    doNotContainWithinFocusZone,\n    styles,\n    cellMargin = 10,\n    defaultSelectedId,\n    focusOnHover,\n    mouseLeaveParentSelector,\n    onChange,\n    // eslint-disable-next-line deprecation/deprecation\n    onColorChanged,\n    onCellHovered,\n    onCellFocused,\n    getColorGridCellStyles,\n    cellHeight,\n    cellWidth,\n    cellBorderWidth,\n  } = props;\n\n  /**\n   *  Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n   */\n  const itemsWithIndex = React.useMemo(() => {\n    return colorCells.map((item, index) => {\n      return { ...item, index: index };\n    });\n  }, [colorCells]);\n\n  const mergedOnChange = React.useCallback(\n    (ev: React.FormEvent<HTMLElement>, newSelectedId: string | undefined) => {\n      // Call both new and old change handlers, and add the extra `color` parameter\n      const newColor = colorCells.filter(c => c.id === newSelectedId)[0]?.color;\n      onChange?.(ev, newSelectedId, newColor);\n      onColorChanged?.(newSelectedId, newColor);\n    },\n    [onChange, onColorChanged, colorCells],\n  );\n\n  const [selectedId, setSelectedId] = useControllableValue(props.selectedId, defaultSelectedId, mergedOnChange);\n\n  const classNames = getClassNames(styles!, {\n    theme: props.theme!,\n    className,\n    cellMargin,\n  });\n\n  const gridStyles = {\n    root: classNames.root,\n    tableCell: classNames.tableCell,\n    focusedContainer: classNames.focusedContainer,\n  };\n\n  /**\n   * If there is only one row of cells, they should use radio semantics,\n   * multi-row swatch cells should use grid semantics.\n   * There are two reasons for this:\n   *   1. Radios are a more simple and understandable control, and a better fit for a single-dimensional picker.\n   *   2. Multiple browsers use heuristics to strip table and grid roles from single-row tables with no column headers.\n   */\n  const isSemanticRadio = colorCells.length <= columnCount;\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  const onSwatchColorPickerBlur = React.useCallback(\n    (event?: React.FocusEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        internalState.cellFocused = false;\n        onCellFocused(undefined, undefined, event);\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  const onMouseEnter = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n      if (internalState.isNavigationIdle && !disabled) {\n        ev.currentTarget.focus();\n      }\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseMove = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n      if (!focusOnHover) {\n        return !internalState.isNavigationIdle || !!disabled;\n      }\n\n      const targetElement = ev.currentTarget as HTMLElement;\n\n      // If navigation is idle and the targetElement is the focused element bail out\n      if (internalState.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n        targetElement.focus();\n      }\n\n      return true;\n    },\n    [focusOnHover, internalState, disabled],\n  );\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  const onMouseLeave = React.useCallback(\n    (ev: React.MouseEvent<HTMLButtonElement>): void => {\n      const parentSelector = mouseLeaveParentSelector;\n\n      if (!focusOnHover || !parentSelector || !internalState.isNavigationIdle || disabled) {\n        return;\n      }\n\n      // Get the elements that math the given selector\n      const elements = document.querySelectorAll(parentSelector);\n\n      // iterate over the elements return to make sure it is a parent of the target and focus it\n      for (let index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if ((elements[index] as any).setActive) {\n            try {\n              (elements[index] as any).setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            (elements[index] as HTMLElement).focus();\n          }\n\n          break;\n        }\n      }\n    },\n    [disabled, focusOnHover, internalState, mouseLeaveParentSelector],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  const onGridCellHovered = React.useCallback(\n    (item?: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (onCellHovered) {\n        item ? onCellHovered(item.id, item.color, event) : onCellHovered(undefined, undefined, event);\n      }\n    },\n    [onCellHovered],\n  );\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  const onGridCellFocused = React.useCallback(\n    (item?: IColorCellProps, event?: React.FormEvent<HTMLButtonElement>): void => {\n      if (onCellFocused) {\n        if (item) {\n          internalState.cellFocused = true;\n          return onCellFocused(item.id, item.color, event);\n        } else {\n          internalState.cellFocused = false;\n          return onCellFocused(undefined, undefined, event);\n        }\n      }\n    },\n    [internalState, onCellFocused],\n  );\n\n  /**\n   * Handle the click on a cell\n   */\n  const onCellClick = React.useCallback(\n    (item: IColorCellProps, event?: React.MouseEvent<HTMLButtonElement>): void => {\n      if (disabled) {\n        return;\n      }\n\n      if (item.id !== selectedId) {\n        if (onCellFocused && internalState.cellFocused) {\n          internalState.cellFocused = false;\n          onCellFocused(undefined, undefined, event);\n        }\n        setSelectedId(item.id, event);\n      }\n    },\n    [disabled, internalState, onCellFocused, selectedId, setSelectedId],\n  );\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  const setNavigationTimeout = React.useCallback(() => {\n    if (!internalState.isNavigationIdle && internalState.navigationIdleTimeoutId !== undefined) {\n      clearTimeout(internalState.navigationIdleTimeoutId);\n      internalState.navigationIdleTimeoutId = undefined;\n    } else {\n      internalState.isNavigationIdle = false;\n    }\n\n    internalState.navigationIdleTimeoutId = setTimeout(() => {\n      internalState.isNavigationIdle = true;\n    }, internalState.navigationIdleDelay);\n  }, [clearTimeout, internalState, setTimeout]);\n\n  /**\n   * Callback used to handle KeyCode events\n   */\n  const onKeyDown = React.useCallback(\n    (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n      if (\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.up ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.down ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.left ||\n        // eslint-disable-next-line deprecation/deprecation\n        ev.which === KeyCodes.right\n      ) {\n        setNavigationTimeout();\n      }\n    },\n    [setNavigationTimeout],\n  );\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  const renderOption = (item: IColorCellProps): JSX.Element => {\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={getColorGridCellStyles}\n        disabled={disabled}\n        onClick={onCellClick}\n        onHover={onGridCellHovered}\n        onFocus={onGridCellFocused}\n        selected={selectedId === item.id}\n        circle={cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={onMouseEnter}\n        onMouseMove={onMouseMove}\n        onMouseLeave={onMouseLeave}\n        onWheel={setNavigationTimeout}\n        onKeyDown={onKeyDown}\n        height={cellHeight}\n        width={cellWidth}\n        borderWidth={cellBorderWidth}\n        isRadio={isSemanticRadio}\n      />\n    );\n  };\n\n  if (colorCells.length < 1 || columnCount < 1) {\n    return null;\n  }\n\n  const onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = renderOption } = props;\n    return onRenderColorCell(item, renderOption) as JSX.Element;\n  };\n  return (\n    <ButtonGrid\n      {...((props as unknown) as IButtonGridProps)}\n      ref={ref}\n      id={id}\n      items={itemsWithIndex}\n      columnCount={columnCount}\n      isSemanticRadio={isSemanticRadio}\n      // eslint-disable-next-line react/jsx-no-bind\n      onRenderItem={onRenderItem}\n      shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n      doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n      onBlur={onSwatchColorPickerBlur}\n      theme={props.theme!}\n      styles={gridStyles}\n    />\n  );\n});\n\nSwatchColorPickerBase.displayName = COMPONENT_NAME;\n"]},"metadata":{},"sourceType":"module"}
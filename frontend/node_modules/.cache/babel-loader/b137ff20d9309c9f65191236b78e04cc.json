{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\n\nvar Autofill =\n/** @class */\nfunction (_super) {\n  __extends(Autofill, _super);\n\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n    _this._onCompositionStart = function (ev) {\n      _this.setState({\n        isComposing: true\n      });\n\n      _this._autoFillEnabled = false;\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n\n      _this.setState({\n        isComposing: false\n      }); // Due to timing, this needs to be async, otherwise no text will be selected.\n\n\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState({\n                inputValue: _this.props.suggestedDisplayValue || ''\n              });\n\n              _this._autoFillEnabled = false;\n            }\n\n            break;\n\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n\n      if (!_this.state.isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      } // If it is not IE11 and currently composing, update the value\n\n\n      if (!(isIE11() && _this.state.isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this.state.isComposing : nativeEventComposing;\n\n        _this._updateValue(value, isComposing);\n      }\n    };\n\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n\n\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var _a = _this.props,\n          onInputChange = _a.onInputChange,\n          onInputValueChange = _a.onInputValueChange;\n\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n\n      _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false\n    };\n    return _this;\n  }\n\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps(); // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return __assign(__assign({}, state), {\n          inputValue: updatedInputValue\n        });\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a = this.props,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n        preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n\n    this._updateValue('', false);\n\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var _a, _b;\n\n    var inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: (_a = inel.selectionStart) !== null && _a !== void 0 ? _a : inel.value.length,\n        end: (_b = inel.selectionEnd) !== null && _b !== void 0 ? _b : inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n\n    return null;\n  };\n\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n\n\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  };\n\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    } // eslint-disable-next-line no-console\n\n\n    console.warn(\"props.value of Autofill should be a string, but it is \" + value + \" with type of \" + typeof value);\n    return value.toString();\n  };\n\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\n\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\n\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n\n      if (typeof val !== 'string') {\n        throw new Error(Autofill.name + \" received non-string value \\\"\" + val + \"\\\" of type \" + typeof val + \" from either input's value or suggestedDisplayValue\");\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"mappings":"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","names":["React","Async","getNativeProps","initializeComponentRef","inputProperties","isIE11","KeyCodes","SELECTION_FORWARD","SELECTION_BACKWARD","__extends","props","_super","_this","createRef","ev","setState","isComposing","_autoFillEnabled","_updateValue","_getCurrentInputValue","inputValue","_tryEnableAutofill","value","_async","setTimeout","onKeyDown","nativeEvent","which","backspace","left","right","suggestedDisplayValue","enableAutofillOnKeyPress","indexOf","state","nativeEventComposing","undefined","newValue","composing","onInputChange","onInputValueChange","defaultVisibleValue","Autofill","updateValueInWillReceiveProps","updatedInputValue","Object","_inputElement","current","inputElement","selectionDirection","selectionEnd","selectionStart","Boolean","_getControlledValue","_","_1","cursor","shouldSelectFullInputValueInComponentDidUpdate","preventValueSelection","differenceIndex","_doesTextStartWith","shouldSelectFullRange","setSelectionRange","length","toLocaleLowerCase","start","end","dir","dispose","nativeProps","style","fontFamily","autoCapitalize","autoComplete","ref","_getDisplayValue","onCompositionStart","_onCompositionStart","onCompositionUpdate","_onCompositionUpdate","onCompositionEnd","_onCompositionEnd","onChange","_onChanged","onInput","_onInputChanged","_onKeyDown","onClick","_onClick","focus","inel","_a","_b","target","oldValue","isComposed","console","warn","toString","down","up","Component","displayValue","text","startWith","process","env","NODE_ENV","_i","val","Error","name"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\Autofill\\Autofill.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport type { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n  isComposing: boolean;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return { ...state, inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false,\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart ?? inel.value.length,\n        end: inel.selectionEnd ?? inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this.setState({ isComposing: true });\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this.setState({ isComposing: false });\n\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState({ inputValue: this.props.suggestedDisplayValue || '' });\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this.state.isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this.state.isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this.state.isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"]},"metadata":{},"sourceType":"module"}
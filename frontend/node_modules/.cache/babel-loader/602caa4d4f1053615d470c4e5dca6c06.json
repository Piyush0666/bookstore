{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, css, allowScrollOnElement, allowOverscrollOnElement, getPropsWithDefaults, KeyCodes, elementContains, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport { useBoolean, useMergedRefs, useWarnings, useConst, useSetTimeout, useId, useUnmount } from '@fluentui/react-hooks';\nvar ZERO = {\n  x: 0,\n  y: 0\n};\nvar DEFAULT_PROPS = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true\n};\nvar getClassNames = classNamesFunction();\n\nvar getMoveDelta = function (ev) {\n  var delta = 10;\n\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nvar useComponentRef = function (props, focusTrapZone) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      focus: function () {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      }\n    };\n  }, [focusTrapZone]);\n};\n\nexport var ModalBase = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var _a, _b, _c, _d, _e;\n\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var allowTouchBodyScroll = props.allowTouchBodyScroll,\n      className = props.className,\n      children = props.children,\n      containerClassName = props.containerClassName,\n      scrollableContentClassName = props.scrollableContentClassName,\n      elementToFocusOnDismiss = props.elementToFocusOnDismiss,\n      firstFocusableSelector = props.firstFocusableSelector,\n      focusTrapZoneProps = props.focusTrapZoneProps,\n      forceFocusInsideTrap = props.forceFocusInsideTrap,\n      // eslint-disable-next-line deprecation/deprecation\n  _f = props.disableRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n  disableRestoreFocus = _f === void 0 ? props.ignoreExternalFocusing : _f,\n      isBlocking = props.isBlocking,\n      isAlert = props.isAlert,\n      isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n      isDarkOverlay = props.isDarkOverlay,\n      onDismiss = props.onDismiss,\n      layerProps = props.layerProps,\n      overlay = props.overlay,\n      isOpen = props.isOpen,\n      titleAriaId = props.titleAriaId,\n      styles = props.styles,\n      subtitleAriaId = props.subtitleAriaId,\n      theme = props.theme,\n      topOffsetFixed = props.topOffsetFixed,\n      responsiveMode = props.responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n  onLayerDidMount = props.onLayerDidMount,\n      isModeless = props.isModeless,\n      dragOptions = props.dragOptions,\n      onDismissed = props.onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n  enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var rootRef = React.useRef(null);\n  var focusTrapZone = React.useRef(null);\n  var focusTrapZoneRef = useMergedRefs(focusTrapZone, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.componentRef);\n  var focusTrapZoneElm = React.useRef(null);\n  var mergedRef = useMergedRefs(rootRef, ref);\n  var modalResponsiveMode = useResponsiveMode(mergedRef);\n  var focusTrapZoneId = useId('ModalFocusTrapZone', focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.id);\n  var win = useWindow();\n\n  var _g = useSetTimeout(),\n      setTimeout = _g.setTimeout,\n      clearTimeout = _g.clearTimeout;\n\n  var _h = React.useState(isOpen),\n      isModalOpen = _h[0],\n      setIsModalOpen = _h[1];\n\n  var _j = React.useState(isOpen),\n      isVisible = _j[0],\n      setIsVisible = _j[1];\n\n  var _k = React.useState(ZERO),\n      coordinates = _k[0],\n      setCoordinates = _k[1];\n\n  var _l = React.useState(),\n      modalRectangleTop = _l[0],\n      setModalRectangleTop = _l[1];\n\n  var _m = useBoolean(false),\n      isModalMenuOpen = _m[0],\n      _o = _m[1],\n      toggleModalMenuOpen = _o.toggle,\n      setModalMenuClose = _o.setFalse;\n\n  var internalState = useConst(function () {\n    return {\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll: allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({})\n    };\n  });\n  var keepInBounds = (dragOptions || {}).keepInBounds;\n  var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : isBlocking && !isModeless;\n  var layerClassName = layerProps === undefined ? '' : layerProps.className;\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    containerClassName: containerClassName,\n    scrollableContentClassName: scrollableContentClassName,\n    isOpen: isOpen,\n    isVisible: isVisible,\n    hasBeenOpened: internalState.hasBeenOpened,\n    modalRectangleTop: modalRectangleTop,\n    topOffsetFixed: topOffsetFixed,\n    isModeless: isModeless,\n    layerClassName: layerClassName,\n    windowInnerHeight: win === null || win === void 0 ? void 0 : win.innerHeight,\n    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n  });\n\n  var mergedLayerProps = __assign(__assign({\n    eventBubblingEnabled: false\n  }, layerProps), {\n    onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n    insertFirst: isModeless,\n    className: classNames.layer\n  }); // Allow the user to scroll within the modal but not on the body\n\n\n  var allowScrollOnModal = React.useCallback(function (elt) {\n    if (elt) {\n      if (internalState.allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, internalState.events);\n      } else {\n        allowScrollOnElement(elt, internalState.events);\n      }\n    } else {\n      internalState.events.off(internalState.scrollableContent);\n    }\n\n    internalState.scrollableContent = elt;\n  }, [internalState]);\n\n  var registerInitialModalPosition = function () {\n    var dialogMain = focusTrapZoneElm.current;\n    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();\n\n    if (modalRectangle) {\n      if (topOffsetFixed) {\n        setModalRectangleTop(modalRectangle.top);\n      }\n\n      if (keepInBounds) {\n        // x/y are unavailable in IE, so use the equivalent left/top\n        internalState.minPosition = {\n          x: -modalRectangle.left,\n          y: -modalRectangle.top\n        };\n        internalState.maxPosition = {\n          x: modalRectangle.left,\n          y: modalRectangle.top\n        };\n      }\n    }\n  };\n  /**\n   * Clamps an axis to a specified min and max position.\n   *\n   * @param axis A string that represents the axis (x/y).\n   * @param position The position on the axis.\n   */\n\n\n  var getClampedAxis = React.useCallback(function (axis, position) {\n    var minPosition = internalState.minPosition,\n        maxPosition = internalState.maxPosition;\n\n    if (keepInBounds && minPosition && maxPosition) {\n      position = Math.max(minPosition[axis], position);\n      position = Math.min(maxPosition[axis], position);\n    }\n\n    return position;\n  }, [keepInBounds, internalState]);\n\n  var handleModalClose = function () {\n    var _a;\n\n    internalState.lastSetCoordinates = ZERO;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n    setIsModalOpen(false);\n    setCoordinates(ZERO);\n    (_a = internalState.disposeOnKeyUp) === null || _a === void 0 ? void 0 : _a.call(internalState);\n    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();\n  };\n\n  var handleDragStart = React.useCallback(function () {\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = false;\n  }, [internalState, setModalMenuClose]);\n  var handleDrag = React.useCallback(function (ev, dragData) {\n    setCoordinates(function (prevValue) {\n      return {\n        x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n        y: getClampedAxis('y', prevValue.y + dragData.delta.y)\n      };\n    });\n  }, [getClampedAxis]);\n  var handleDragStop = React.useCallback(function () {\n    if (focusTrapZone.current) {\n      focusTrapZone.current.focus();\n    }\n  }, []);\n\n  var handleEnterKeyboardMoveMode = function () {\n    // We need a global handleKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    var handleKeyDown = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        ev.preventDefault();\n        ev.stopPropagation();\n        return;\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      var newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n\n      if (isModalMenuOpen && newLocal) {\n        setModalMenuClose();\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n        internalState.isInKeyboardMoveMode = false;\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (internalState.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta_1 = getMoveDelta(ev); // eslint-disable-next-line deprecation/deprecation\n\n        switch (ev.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            setCoordinates(internalState.lastSetCoordinates);\n\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO; // setIsInKeyboardMoveMode(false);\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y - delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: prevValue.x,\n                  y: getClampedAxis('y', prevValue.y + delta_1)\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x - delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              setCoordinates(function (prevValue) {\n                return {\n                  x: getClampedAxis('x', prevValue.x + delta_1),\n                  y: prevValue.y\n                };\n              });\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    internalState.lastSetCoordinates = coordinates;\n    setModalMenuClose();\n    internalState.isInKeyboardMoveMode = true;\n    internalState.events.on(win, 'keydown', handleKeyDown, true\n    /* useCapture */\n    );\n\n    internalState.disposeOnKeyDown = function () {\n      internalState.events.off(win, 'keydown', handleKeyDown, true\n      /* useCapture */\n      );\n      internalState.disposeOnKeyDown = undefined;\n    };\n  };\n\n  var handleExitKeyboardMoveMode = function (ev) {\n    var _a, _b;\n\n    (_a = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(focusTrapZoneProps, ev);\n    internalState.lastSetCoordinates = ZERO;\n    internalState.isInKeyboardMoveMode = false;\n    (_b = internalState.disposeOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(internalState);\n  };\n\n  var registerForKeyUp = function () {\n    var handleKeyUp = function (ev) {\n      // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // eslint-disable-next-line deprecation/deprecation\n      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n        if (elementContains(internalState.scrollableContent, ev.target)) {\n          toggleModalMenuOpen();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    if (!internalState.disposeOnKeyUp) {\n      internalState.events.on(win, 'keyup', handleKeyUp, true\n      /* useCapture */\n      );\n\n      internalState.disposeOnKeyUp = function () {\n        internalState.events.off(win, 'keyup', handleKeyUp, true\n        /* useCapture */\n        );\n        internalState.disposeOnKeyUp = undefined;\n      };\n    }\n  };\n\n  React.useEffect(function () {\n    clearTimeout(internalState.onModalCloseTimer); // Opening the dialog\n\n    if (isOpen) {\n      // This must be done after the modal content has rendered\n      requestAnimationFrame(function () {\n        return setTimeout(registerInitialModalPosition, 0);\n      });\n      setIsModalOpen(true); // Add a keyUp handler for all key up events once the dialog is open.\n\n      if (dragOptions) {\n        registerForKeyUp();\n      }\n\n      internalState.hasBeenOpened = true;\n      setIsVisible(true);\n    } // Closing the dialog\n\n\n    if (!isOpen && isModalOpen) {\n      internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n      setIsVisible(false);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n\n  }, [isModalOpen, isOpen]);\n  useUnmount(function () {\n    internalState.events.dispose();\n  });\n  useComponentRef(props, focusTrapZone);\n  useDebugWarnings(props);\n  var modalContent = React.createElement(FocusTrapZone, __assign({}, focusTrapZoneProps, {\n    id: focusTrapZoneId,\n    ref: focusTrapZoneElm,\n    componentRef: focusTrapZoneRef,\n    className: css(classNames.main, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.className),\n    elementToFocusOnDismiss: (_a = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.elementToFocusOnDismiss) !== null && _a !== void 0 ? _a : elementToFocusOnDismiss,\n    isClickableOutsideFocusTrap: (_b = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.isClickableOutsideFocusTrap) !== null && _b !== void 0 ? _b : isModeless || isClickableOutsideFocusTrap || !isBlocking,\n    disableRestoreFocus: (_c = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.disableRestoreFocus) !== null && _c !== void 0 ? _c : disableRestoreFocus,\n    forceFocusInsideTrap: ((_d = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.forceFocusInsideTrap) !== null && _d !== void 0 ? _d : forceFocusInsideTrap) && !isModeless,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector: (focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.firstFocusableSelector) || firstFocusableSelector,\n    focusPreviouslyFocusedInnerElement: (_e = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.focusPreviouslyFocusedInnerElement) !== null && _e !== void 0 ? _e : true,\n    onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined\n  }), dragOptions && internalState.isInKeyboardMoveMode && React.createElement(\"div\", {\n    className: classNames.keyboardMoveIconContainer\n  }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n    iconName: \"move\",\n    className: classNames.keyboardMoveIcon\n  })), React.createElement(\"div\", {\n    ref: allowScrollOnModal,\n    className: classNames.scrollableContent,\n    \"data-is-scrollable\": true\n  }, dragOptions && isModalMenuOpen && React.createElement(dragOptions.menu, {\n    items: [{\n      key: 'move',\n      text: dragOptions.moveMenuItemText,\n      onClick: handleEnterKeyboardMoveMode\n    }, {\n      key: 'close',\n      text: dragOptions.closeMenuItemText,\n      onClick: handleModalClose\n    }],\n    onDismiss: setModalMenuClose,\n    alignTargetEdge: true,\n    coverTarget: true,\n    directionalHint: DirectionalHint.topLeftEdge,\n    directionalHintFixed: true,\n    shouldFocusOnMount: true,\n    target: internalState.scrollableContent\n  }), children));\n  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React.createElement(Layer, __assign({\n    ref: mergedRef\n  }, mergedLayerProps), React.createElement(Popup, {\n    role: isAlertRole ? 'alertdialog' : 'dialog',\n    ariaLabelledBy: titleAriaId,\n    ariaDescribedBy: subtitleAriaId,\n    onDismiss: onDismiss,\n    shouldRestoreFocus: !disableRestoreFocus,\n    // Modeless modals shouldn't hide siblings.\n    // Popup will automatically handle this based on the aria-modal setting.\n    enableAriaHiddenSiblings: enableAriaHiddenSiblings,\n    \"aria-modal\": !isModeless\n  }, React.createElement(\"div\", {\n    className: classNames.root,\n    role: !isModeless ? 'document' : undefined\n  }, !isModeless && React.createElement(Overlay, __assign({\n    \"aria-hidden\": true,\n    isDarkThemed: isDarkOverlay,\n    onClick: isBlocking ? undefined : onDismiss,\n    allowTouchBodyScroll: allowTouchBodyScroll\n  }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n    handleSelector: dragOptions.dragHandleSelector || \"#\" + focusTrapZoneId,\n    preventDragSelector: \"button\",\n    onStart: handleDragStart,\n    onDragChange: handleDrag,\n    onStop: handleDragStop,\n    position: coordinates\n  }, modalContent) : modalContent))) || null;\n});\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props: props,\n      deprecations: {\n        onLayerDidMount: 'layerProps.onLayerDidMount'\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","css","allowScrollOnElement","allowOverscrollOnElement","getPropsWithDefaults","KeyCodes","elementContains","EventGroup","FocusTrapZone","animationDuration","Overlay","Layer","Popup","ResponsiveMode","useResponsiveMode","DirectionalHint","Icon","DraggableZone","useWindow","useBoolean","useMergedRefs","useWarnings","useConst","useSetTimeout","useId","useUnmount","ZERO","x","y","DEFAULT_PROPS","isOpen","isDarkOverlay","className","containerClassName","enableAriaHiddenSiblings","getClassNames","getMoveDelta","ev","delta","shiftKey","ctrlKey","useComponentRef","props","focusTrapZone","useImperativeHandle","componentRef","focus","current","ModalBase","forwardRef","propsWithoutDefaults","ref","children","scrollableContentClassName","elementToFocusOnDismiss","firstFocusableSelector","focusTrapZoneProps","forceFocusInsideTrap","_f","disableRestoreFocus","ignoreExternalFocusing","isBlocking","isAlert","isClickableOutsideFocusTrap","onDismiss","layerProps","overlay","titleAriaId","styles","subtitleAriaId","theme","topOffsetFixed","responsiveMode","onLayerDidMount","isModeless","dragOptions","onDismissed","rootRef","useRef","focusTrapZoneRef","focusTrapZoneElm","mergedRef","modalResponsiveMode","focusTrapZoneId","id","win","setTimeout","clearTimeout","useState","isModalOpen","setIsModalOpen","isVisible","setIsVisible","coordinates","setCoordinates","modalRectangleTop","setModalRectangleTop","isModalMenuOpen","_o","toggleModalMenuOpen","setModalMenuClose","internalState","onModalCloseTimer","allowTouchBodyScroll","scrollableContent","lastSetCoordinates","events","keepInBounds","isAlertRole","layerClassName","undefined","classNames","hasBeenOpened","windowInnerHeight","innerHeight","isDefaultDragHandle","dragHandleSelector","mergedLayerProps","eventBubblingEnabled","insertFirst","layer","allowScrollOnModal","useCallback","elt","off","registerInitialModalPosition","dialogMain","modalRectangle","getBoundingClientRect","top","minPosition","left","maxPosition","getClampedAxis","axis","position","Math","max","min","handleModalClose","isInKeyboardMoveMode","disposeOnKeyUp","_a","handleDragStart","handleDrag","dragData","prevValue","handleDragStop","handleEnterKeyboardMoveMode","handleKeyDown","altKey","keyCode","space","preventDefault","stopPropagation","newLocal","escape","enter","handledEvent","delta_1","up","down","right","on","disposeOnKeyDown","handleExitKeyboardMoveMode","onBlur","_b","registerForKeyUp","handleKeyUp","target","useEffect","requestAnimationFrame","parseFloat","dispose","useDebugWarnings","modalContent","__assign","main","_c","_d","focusPreviouslyFocusedInnerElement","_e","keyboardMoveIconContainer","keyboardMoveIconProps","iconName","keyboardMoveIcon","menu","items","key","text","moveMenuItemText","onClick","closeMenuItemText","alignTargetEdge","coverTarget","directionalHint","topLeftEdge","directionalHintFixed","shouldFocusOnMount","small","role","ariaLabelledBy","ariaDescribedBy","shouldRestoreFocus","root","isDarkThemed","handleSelector","preventDragSelector","onStart","onDragChange","onStop","displayName","process","env","NODE_ENV","name","deprecations"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\Modal\\Modal.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  css,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  getPropsWithDefaults,\n  KeyCodes,\n  elementContains,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../../Popup';\nimport { ResponsiveMode, useResponsiveMode } from '../../ResponsiveMode';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Icon } from '../../Icon';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { useWindow } from '@fluentui/react-window-provider';\nimport {\n  useBoolean,\n  useMergedRefs,\n  useWarnings,\n  useConst,\n  useSetTimeout,\n  useId,\n  useUnmount,\n} from '@fluentui/react-hooks';\nimport type { IFocusTrapZone } from '../../FocusTrapZone';\nimport type { IDragOptions, IModalProps, IModalStyleProps, IModalStyles } from './Modal.types';\nimport type { ILayerProps } from '../../Layer';\nimport type { ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\ninterface IModalInternalState {\n  onModalCloseTimer: number;\n  allowTouchBodyScroll?: boolean;\n  scrollableContent: HTMLDivElement | null;\n  lastSetCoordinates: ICoordinates;\n  /** Minimum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  minPosition?: ICoordinates;\n  /** Maximum clamped position, if dragging and clamping (`dragOptions.keepInBounds`) are enabled */\n  maxPosition?: ICoordinates;\n  events: EventGroup;\n  /** Ensures we dispose the same keydown callback as was registered */\n  disposeOnKeyDown?: () => void;\n  /** Ensures we dispose the same keyup callback as was registered (also tracks whether keyup has been registered) */\n  disposeOnKeyUp?: () => void;\n  isInKeyboardMoveMode?: boolean;\n  hasBeenOpened?: boolean;\n}\n\nconst ZERO: ICoordinates = { x: 0, y: 0 };\n\nconst DEFAULT_PROPS: Partial<IModalProps> = {\n  isOpen: false,\n  isDarkOverlay: true,\n  className: '',\n  containerClassName: '',\n  enableAriaHiddenSiblings: true,\n};\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\n\nconst getMoveDelta = (ev: React.KeyboardEvent<HTMLElement>): number => {\n  let delta = 10;\n  if (ev.shiftKey) {\n    if (!ev.ctrlKey) {\n      delta = 50;\n    }\n  } else if (ev.ctrlKey) {\n    delta = 1;\n  }\n\n  return delta;\n};\n\nconst useComponentRef = (props: IModalProps, focusTrapZone: React.RefObject<IFocusTrapZone>) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      focus() {\n        if (focusTrapZone.current) {\n          focusTrapZone.current.focus();\n        }\n      },\n    }),\n    [focusTrapZone],\n  );\n};\n\nexport const ModalBase: React.FunctionComponent<IModalProps> = React.forwardRef<HTMLDivElement, IModalProps>(\n  (propsWithoutDefaults, ref) => {\n    const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n    const {\n      allowTouchBodyScroll,\n      className,\n      children,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      focusTrapZoneProps,\n      forceFocusInsideTrap,\n      // eslint-disable-next-line deprecation/deprecation\n      disableRestoreFocus = props.ignoreExternalFocusing,\n      isBlocking,\n      isAlert,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      isOpen,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      responsiveMode,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      onDismissed,\n      // eslint-disable-next-line deprecation/deprecation\n      enableAriaHiddenSiblings,\n    } = props;\n\n    const rootRef = React.useRef<HTMLDivElement>(null);\n    const focusTrapZone = React.useRef<IFocusTrapZone>(null);\n    const focusTrapZoneRef = useMergedRefs(focusTrapZone, focusTrapZoneProps?.componentRef);\n    const focusTrapZoneElm = React.useRef<HTMLDivElement>(null);\n    const mergedRef = useMergedRefs(rootRef, ref);\n\n    const modalResponsiveMode = useResponsiveMode(mergedRef);\n\n    const focusTrapZoneId = useId('ModalFocusTrapZone', focusTrapZoneProps?.id);\n\n    const win = useWindow();\n\n    const { setTimeout, clearTimeout } = useSetTimeout();\n\n    const [isModalOpen, setIsModalOpen] = React.useState(isOpen);\n    const [isVisible, setIsVisible] = React.useState(isOpen);\n    const [coordinates, setCoordinates] = React.useState<ICoordinates>(ZERO);\n    const [modalRectangleTop, setModalRectangleTop] = React.useState<number | undefined>();\n\n    const [isModalMenuOpen, { toggle: toggleModalMenuOpen, setFalse: setModalMenuClose }] = useBoolean(false);\n\n    const internalState = useConst<IModalInternalState>(() => ({\n      onModalCloseTimer: 0,\n      allowTouchBodyScroll,\n      scrollableContent: null,\n      lastSetCoordinates: ZERO,\n      events: new EventGroup({}),\n    }));\n\n    const { keepInBounds } = dragOptions || ({} as IDragOptions);\n    const isAlertRole = isAlert ?? (isBlocking && !isModeless);\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened: internalState.hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      windowInnerHeight: win?.innerHeight,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps: ILayerProps = {\n      eventBubblingEnabled: false,\n      ...layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n\n    // Allow the user to scroll within the modal but not on the body\n    const allowScrollOnModal = React.useCallback(\n      (elt: HTMLDivElement | null): void => {\n        if (elt) {\n          if (internalState.allowTouchBodyScroll) {\n            allowOverscrollOnElement(elt, internalState.events);\n          } else {\n            allowScrollOnElement(elt, internalState.events);\n          }\n        } else {\n          internalState.events.off(internalState.scrollableContent);\n        }\n        internalState.scrollableContent = elt;\n      },\n      [internalState],\n    );\n\n    const registerInitialModalPosition = (): void => {\n      const dialogMain = focusTrapZoneElm.current;\n      const modalRectangle = dialogMain?.getBoundingClientRect();\n\n      if (modalRectangle) {\n        if (topOffsetFixed) {\n          setModalRectangleTop(modalRectangle.top);\n        }\n\n        if (keepInBounds) {\n          // x/y are unavailable in IE, so use the equivalent left/top\n          internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };\n          internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };\n        }\n      }\n    };\n\n    /**\n     * Clamps an axis to a specified min and max position.\n     *\n     * @param axis A string that represents the axis (x/y).\n     * @param position The position on the axis.\n     */\n    const getClampedAxis = React.useCallback(\n      (axis: keyof ICoordinates, position: number) => {\n        const { minPosition, maxPosition } = internalState;\n        if (keepInBounds && minPosition && maxPosition) {\n          position = Math.max(minPosition[axis], position);\n          position = Math.min(maxPosition[axis], position);\n        }\n        return position;\n      },\n      [keepInBounds, internalState],\n    );\n\n    const handleModalClose = (): void => {\n      internalState.lastSetCoordinates = ZERO;\n\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n      setIsModalOpen(false);\n      setCoordinates(ZERO);\n\n      internalState.disposeOnKeyUp?.();\n\n      onDismissed?.();\n    };\n\n    const handleDragStart = React.useCallback((): void => {\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = false;\n    }, [internalState, setModalMenuClose]);\n\n    const handleDrag = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, dragData: IDragData): void => {\n        setCoordinates(prevValue => ({\n          x: getClampedAxis('x', prevValue.x + dragData.delta.x),\n          y: getClampedAxis('y', prevValue.y + dragData.delta.y),\n        }));\n      },\n      [getClampedAxis],\n    );\n\n    const handleDragStop = React.useCallback((): void => {\n      if (focusTrapZone.current) {\n        focusTrapZone.current.focus();\n      }\n    }, []);\n\n    const handleEnterKeyboardMoveMode = () => {\n      // We need a global handleKeyDown event when we are in the move mode so that we can\n      // handle the key presses and the components inside the modal do not get the events\n      const handleKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          // CTRL + ALT + SPACE is handled during keyUp\n          ev.preventDefault();\n          ev.stopPropagation();\n          return;\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        const newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;\n        if (isModalMenuOpen && newLocal) {\n          setModalMenuClose();\n        }\n\n        // eslint-disable-next-line deprecation/deprecation\n        if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {\n          internalState.isInKeyboardMoveMode = false;\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        if (internalState.isInKeyboardMoveMode) {\n          let handledEvent = true;\n          const delta = getMoveDelta(ev);\n\n          // eslint-disable-next-line deprecation/deprecation\n          switch (ev.keyCode) {\n            /* eslint-disable no-fallthrough */\n            case KeyCodes.escape:\n              setCoordinates(internalState.lastSetCoordinates);\n            case KeyCodes.enter: {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              internalState.lastSetCoordinates = ZERO;\n              // setIsInKeyboardMoveMode(false);\n              break;\n            }\n            case KeyCodes.up: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y - delta) }));\n              break;\n            }\n            case KeyCodes.down: {\n              setCoordinates(prevValue => ({ x: prevValue.x, y: getClampedAxis('y', prevValue.y + delta) }));\n              break;\n            }\n            case KeyCodes.left: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x - delta), y: prevValue.y }));\n              break;\n            }\n            case KeyCodes.right: {\n              setCoordinates(prevValue => ({ x: getClampedAxis('x', prevValue.x + delta), y: prevValue.y }));\n              break;\n            }\n            default: {\n              handledEvent = false;\n            }\n          }\n          if (handledEvent) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      internalState.lastSetCoordinates = coordinates;\n      setModalMenuClose();\n      internalState.isInKeyboardMoveMode = true;\n\n      internalState.events.on(win, 'keydown', handleKeyDown, true /* useCapture */);\n      internalState.disposeOnKeyDown = () => {\n        internalState.events.off(win, 'keydown', handleKeyDown, true /* useCapture */);\n        internalState.disposeOnKeyDown = undefined;\n      };\n    };\n\n    const handleExitKeyboardMoveMode = (ev: React.FocusEvent<HTMLDivElement>) => {\n      focusTrapZoneProps?.onBlur?.(ev);\n      internalState.lastSetCoordinates = ZERO;\n      internalState.isInKeyboardMoveMode = false;\n      internalState.disposeOnKeyDown?.();\n    };\n\n    const registerForKeyUp = (): void => {\n      const handleKeyUp = (ev: React.KeyboardEvent<HTMLElement>): void => {\n        // Needs to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n        // eslint-disable-next-line deprecation/deprecation\n        if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {\n          if (elementContains(internalState.scrollableContent, ev.target as HTMLElement)) {\n            toggleModalMenuOpen();\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n        }\n      };\n\n      if (!internalState.disposeOnKeyUp) {\n        internalState.events.on(win, 'keyup', handleKeyUp, true /* useCapture */);\n        internalState.disposeOnKeyUp = () => {\n          internalState.events.off(win, 'keyup', handleKeyUp, true /* useCapture */);\n          internalState.disposeOnKeyUp = undefined;\n        };\n      }\n    };\n\n    React.useEffect(() => {\n      clearTimeout(internalState.onModalCloseTimer);\n      // Opening the dialog\n      if (isOpen) {\n        // This must be done after the modal content has rendered\n        requestAnimationFrame(() => setTimeout(registerInitialModalPosition, 0));\n\n        setIsModalOpen(true);\n\n        // Add a keyUp handler for all key up events once the dialog is open.\n        if (dragOptions) {\n          registerForKeyUp();\n        }\n\n        internalState.hasBeenOpened = true;\n        setIsVisible(true);\n      }\n\n      // Closing the dialog\n      if (!isOpen && isModalOpen) {\n        internalState.onModalCloseTimer = setTimeout(handleModalClose, parseFloat(animationDuration) * 1000);\n        setIsVisible(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run if isModalOpen or isOpen mutates.\n    }, [isModalOpen, isOpen]);\n\n    useUnmount(() => {\n      internalState.events.dispose();\n    });\n\n    useComponentRef(props, focusTrapZone);\n    useDebugWarnings(props);\n\n    const modalContent = (\n      <FocusTrapZone\n        {...focusTrapZoneProps}\n        id={focusTrapZoneId}\n        ref={focusTrapZoneElm}\n        componentRef={focusTrapZoneRef}\n        className={css(classNames.main, focusTrapZoneProps?.className)}\n        elementToFocusOnDismiss={focusTrapZoneProps?.elementToFocusOnDismiss ?? elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={\n          focusTrapZoneProps?.isClickableOutsideFocusTrap ?? (isModeless || isClickableOutsideFocusTrap || !isBlocking)\n        }\n        disableRestoreFocus={focusTrapZoneProps?.disableRestoreFocus ?? disableRestoreFocus}\n        forceFocusInsideTrap={(focusTrapZoneProps?.forceFocusInsideTrap ?? forceFocusInsideTrap) && !isModeless}\n        // eslint-disable-next-line deprecation/deprecation\n        firstFocusableSelector={focusTrapZoneProps?.firstFocusableSelector || firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement={focusTrapZoneProps?.focusPreviouslyFocusedInnerElement ?? true}\n        onBlur={internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : undefined}\n        // enableAriaHiddenSiblings is handled by the Popup\n      >\n        {dragOptions && internalState.isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable>\n          {dragOptions && isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: handleModalClose },\n              ]}\n              onDismiss={setModalMenuClose}\n              alignTargetEdge\n              coverTarget\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed\n              shouldFocusOnMount\n              target={internalState.scrollableContent}\n            />\n          )}\n          {children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    return (\n      (isModalOpen && modalResponsiveMode! >= (responsiveMode || ResponsiveMode.small) && (\n        <Layer ref={mergedRef} {...mergedLayerProps}>\n          <Popup\n            role={isAlertRole ? 'alertdialog' : 'dialog'}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!disableRestoreFocus}\n            // Modeless modals shouldn't hide siblings.\n            // Popup will automatically handle this based on the aria-modal setting.\n            enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n            aria-modal={!isModeless}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  aria-hidden={true}\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : onDismiss}\n                  allowTouchBodyScroll={allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `#${focusTrapZoneId}`}\n                  preventDragSelector=\"button\"\n                  onStart={handleDragStart}\n                  onDragChange={handleDrag}\n                  onStop={handleDragStop}\n                  position={coordinates}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      )) ||\n      null\n    );\n  },\n);\nModalBase.displayName = 'Modal';\n\nfunction useDebugWarnings(props: IModalProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: 'Modal',\n      props,\n      deprecations: { onLayerDidMount: 'layerProps.onLayerDidMount' },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
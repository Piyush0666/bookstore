{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { ZIndexes } from '../../../Styling';\nimport { Layer } from '../../../Layer'; // Utilites/Helpers\n\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, EventGroup, getPropsWithDefaults } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../Positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n}; // In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\n\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\nvar DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge\n};\n\nfunction useCachedBounds(props, targetWindow) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n  var positioningBounds = React.useRef();\n\n  var getCachedBounds = function () {\n    if (!positioningBounds.current) {\n      var currentBounds = props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + props.minPagePadding,\n          left: 0 + props.minPagePadding,\n          right: targetWindow.innerWidth - props.minPagePadding,\n          bottom: targetWindow.innerHeight - props.minPagePadding,\n          width: targetWindow.innerWidth - props.minPagePadding * 2,\n          height: targetWindow.innerHeight - props.minPagePadding * 2\n        };\n      }\n\n      positioningBounds.current = currentBounds;\n    }\n\n    return positioningBounds.current;\n  };\n\n  return getCachedBounds;\n}\n\nfunction usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds) {\n  var async = useAsync();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n\n  var _a = React.useState(),\n      positions = _a[0],\n      setPositions = _a[1];\n\n  var positionAttempts = React.useRef(0);\n\n  var updateAsyncPosition = function () {\n    async.requestAnimationFrame(function () {\n      return updatePosition();\n    });\n  };\n\n  var updatePosition = function () {\n    var offsetFromTarget = props.offsetFromTarget,\n        onPositioned = props.onPositioned;\n    var hostElement = positionedHost.current;\n    var positioningContainerElement = contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, props);\n\n      currentProps.bounds = getCachedBounds();\n      currentProps.target = targetRef.current;\n      var target = currentProps.target;\n\n      if (target) {\n        // Check if the target is an Element or a MouseEvent and the document contains it\n        // or don't check anything else if the target is a Point or Rectangle\n        if (!target.getBoundingClientRect && !target.preventDefault || document.body.contains(target)) {\n          currentProps.gapSpace = offsetFromTarget;\n          var newPositions = positionElement(currentProps, hostElement, positioningContainerElement); // Set the new position only when the positions are not exists or one of the new positioningContainer\n          // positions are different. The position should not change if the position is within 2 decimal places.\n\n          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {\n            // We should not reposition the positioningContainer more than a few times, if it is then the content is\n            // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n          } else {\n            positionAttempts.current = 0;\n            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(newPositions);\n          }\n        } else if (positions !== undefined) {\n          setPositions(undefined);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n\n  React.useEffect(updateAsyncPosition);\n  return [positions, updateAsyncPosition];\n}\n\nfunction useSetInitialFocus(_a, contentHost, positions) {\n  var setInitialFocus = _a.setInitialFocus;\n  var didSetInitialFocus = React.useRef(false);\n  React.useEffect(function () {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\n\nfunction useMaxHeight(_a, targetRef, getCachedBounds) {\n  var directionalHintFixed = _a.directionalHintFixed,\n      offsetFromTarget = _a.offsetFromTarget,\n      directionalHint = _a.directionalHint,\n      target = _a.target;\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n\n  var maxHeight = React.useRef(); // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n\n  React.useEffect(function () {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n\n  var getCachedMaxHeight = function () {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(targetRef.current, directionalHint, gapSpace, getCachedBounds());\n      } else {\n        maxHeight.current = getCachedBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n\n    return maxHeight.current;\n  };\n\n  return getCachedMaxHeight;\n}\n\nfunction useAutoDismissEvents(_a, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition) {\n  var onDismiss = _a.onDismiss,\n      preventDismissOnScroll = _a.preventDismissOnScroll;\n  var async = useAsync();\n  var onResize = React.useCallback(function (ev) {\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      updateAsyncPosition();\n    }\n  }, [onDismiss, updateAsyncPosition]);\n  var dismissOnLostFocus = React.useCallback(function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n\n    if (!targetRef.current && clickedOutsideCallout || ev.target !== targetWindow && clickedOutsideCallout && (targetRef.current.stopPropagation || !targetRef.current || target !== targetRef.current && !elementContains(targetRef.current, target))) {\n      onResize(ev);\n    }\n  }, [onResize, positionedHost, targetRef, targetWindow]);\n  var dismissOnScroll = React.useCallback(function (ev) {\n    if (positions && !preventDismissOnScroll) {\n      dismissOnLostFocus(ev);\n    }\n  }, [dismissOnLostFocus, positions, preventDismissOnScroll]);\n  React.useEffect(function () {\n    var events = new EventGroup({}); // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n\n    async.setTimeout(function () {\n      var _a, _b;\n\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on((_a = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _a === void 0 ? void 0 : _a.body, 'focus', dismissOnLostFocus, true);\n      events.on((_b = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document) === null || _b === void 0 ? void 0 : _b.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n    return function () {\n      return events.dispose();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, [dismissOnScroll]);\n}\n\nexport function useHeightOffset(_a, contentHost) {\n  var finalHeight = _a.finalHeight;\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n\n  var _b = React.useState(0),\n      heightOffset = _b[0],\n      setHeightOffset = _b[1];\n\n  var async = useAsync();\n  var setHeightOffsetTimer = React.useRef(0);\n  /** Animates the height if finalHeight was given. */\n\n  var setHeightOffsetEveryFrame = function () {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(function () {\n        if (!contentHost.current) {\n          return;\n        }\n\n        var positioningContainerMainElem = contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        setHeightOffset(heightOffset + scrollDiff);\n\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n\n\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n  return heightOffset;\n}\nexport var PositioningContainer = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults); // @TODO rename to reflect the name of this class\n\n  var contentHost = React.useRef(null);\n  /**\n   * The primary positioned div.\n   */\n\n  var positionedHost = React.useRef(null);\n  var rootRef = useMergedRefs(forwardedRef, positionedHost);\n\n  var _a = useTarget(props.target, positionedHost),\n      targetRef = _a[0],\n      targetWindow = _a[1];\n\n  var getCachedBounds = useCachedBounds(props, targetWindow);\n\n  var _b = usePositionState(props, positionedHost, contentHost, targetRef, getCachedBounds),\n      positions = _b[0],\n      updateAsyncPosition = _b[1];\n\n  var getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  var heightOffset = useHeightOffset(props, contentHost);\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition); // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n\n  React.useEffect(function () {\n    var _a;\n\n    return (_a = props.onLayerMounted) === null || _a === void 0 ? void 0 : _a.call(props);\n  }, []); // If there is no target window then we are likely in server side rendering and we should not render anything.\n\n  if (!targetWindow) {\n    return null;\n  }\n\n  var className = props.className,\n      doNotLayer = props.doNotLayer,\n      positioningContainerWidth = props.positioningContainerWidth,\n      positioningContainerMaxHeight = props.positioningContainerMaxHeight,\n      children = props.children;\n  var styles = getClassNames();\n  var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n  var getContentMaxHeight = getCachedMaxHeight() + heightOffset;\n  var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n  var content = React.createElement(\"div\", {\n    ref: rootRef,\n    className: css('ms-PositioningContainer', styles.container)\n  }, React.createElement(\"div\", {\n    className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n      width: positioningContainerWidth\n    }, doNotLayer && {\n      zIndex: ZIndexes.Layer\n    }),\n    style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n    // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n    tabIndex: -1,\n    ref: contentHost\n  }, children, // @TODO apply to the content container\n  contentMaxHeight));\n  return doNotLayer ? content : React.createElement(Layer, null, content);\n});\nPositioningContainer.displayName = 'PositioningContainer';\n\nfunction arePositionsEqual(positions, newPosition) {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions, newPositions) {\n  for (var key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      var oldPositionEdge = oldPositions[key];\n      var newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}","map":{"version":3,"mappings":"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","names":["React","getClassNames","ZIndexes","Layer","DirectionalHint","css","elementContains","focusFirstChild","EventGroup","getPropsWithDefaults","getMaxHeight","positionElement","RectangleEdge","AnimationClassNames","mergeStyles","useMergedRefs","useAsync","useTarget","OFF_SCREEN_STYLE","opacity","BORDER_WIDTH","SLIDE_ANIMATIONS","_a","top","bottom","left","right","DEFAULT_PROPS","preventDismissOnScroll","offsetFromTarget","minPagePadding","directionalHint","bottomAutoEdge","useCachedBounds","props","targetWindow","positioningBounds","useRef","getCachedBounds","current","currentBounds","bounds","innerWidth","innerHeight","width","height","usePositionState","positionedHost","contentHost","targetRef","async","useState","positions","setPositions","positionAttempts","updateAsyncPosition","requestAnimationFrame","updatePosition","onPositioned","hostElement","positioningContainerElement","currentProps","__assign","target","getBoundingClientRect","preventDefault","document","body","contains","gapSpace","newPositions","arePositionsEqual","undefined","useEffect","useSetInitialFocus","setInitialFocus","didSetInitialFocus","useMaxHeight","directionalHintFixed","maxHeight","getCachedMaxHeight","useAutoDismissEvents","onDismiss","onResize","useCallback","ev","dismissOnLostFocus","clickedOutsideCallout","stopPropagation","dismissOnScroll","events","setTimeout","on","throttle","_b","dispose","useHeightOffset","finalHeight","heightOffset","setHeightOffset","setHeightOffsetTimer","setHeightOffsetEveryFrame","positioningContainerMainElem","lastChild","cardScrollHeight","scrollHeight","cardCurrHeight","offsetHeight","scrollDiff","cancelAnimationFrame","PositioningContainer","forwardRef","propsWithoutDefaults","forwardedRef","rootRef","onLayerMounted","doNotLayer","positioningContainerWidth","positioningContainerMaxHeight","children","styles","directionalClassName","targetEdge","getContentMaxHeight","contentMaxHeight","content","ref","className","container","root","zIndex","style","elementPosition","tabIndex","displayName","newPosition","comparePositions","oldPositions","key","hasOwnProperty","oldPositionEdge","newPositionEdge","toFixed"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\Coachmark\\src\\components\\Coachmark\\PositioningContainer\\PositioningContainer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { ZIndexes } from '../../../Styling';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, EventGroup, getPropsWithDefaults } from '../../../Utilities';\n\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../Positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nimport { useMergedRefs, useAsync, useTarget } from '@fluentui/react-hooks';\nimport type { IPositioningContainerProps } from './PositioningContainer.types';\nimport type { Point, IRectangle } from '../../../Utilities';\nimport type { IPositionedData, IPositionProps, IPosition } from '../../../Positioning';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work properly we need to set the border.\n// The value is arbitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20',\n} as const;\n\nconst DEFAULT_PROPS = {\n  preventDismissOnScroll: false,\n  offsetFromTarget: 0,\n  minPagePadding: 8,\n  directionalHint: DirectionalHint.bottomAutoEdge,\n};\n\nfunction useCachedBounds(props: IPositioningContainerProps, targetWindow: Window | undefined) {\n  /** The bounds used when determining if and where the PositioningContainer should be placed. */\n  const positioningBounds = React.useRef<IRectangle>();\n\n  const getCachedBounds = (): IRectangle => {\n    if (!positioningBounds.current) {\n      let currentBounds = props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + props.minPagePadding!,\n          left: 0 + props.minPagePadding!,\n          right: targetWindow!.innerWidth - props.minPagePadding!,\n          bottom: targetWindow!.innerHeight - props.minPagePadding!,\n          width: targetWindow!.innerWidth - props.minPagePadding! * 2,\n          height: targetWindow!.innerHeight - props.minPagePadding! * 2,\n        };\n      }\n      positioningBounds.current = currentBounds;\n    }\n    return positioningBounds.current;\n  };\n\n  return getCachedBounds;\n}\n\nfunction usePositionState(\n  props: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  const async = useAsync();\n  /**\n   * Current set of calculated positions for the outermost parent container.\n   */\n  const [positions, setPositions] = React.useState<IPositionedData>();\n  const positionAttempts = React.useRef(0);\n\n  const updateAsyncPosition = (): void => {\n    async.requestAnimationFrame(() => updatePosition());\n  };\n\n  const updatePosition = (): void => {\n    const { offsetFromTarget, onPositioned } = props;\n    const hostElement = positionedHost.current;\n    const positioningContainerElement = contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      const currentProps: IPositionProps = { ...props } as IPositionProps;\n      currentProps!.bounds = getCachedBounds();\n      currentProps!.target = targetRef.current!;\n      const { target } = currentProps;\n\n      if (target) {\n        // Check if the target is an Element or a MouseEvent and the document contains it\n        // or don't check anything else if the target is a Point or Rectangle\n        if (\n          (!(target as Element).getBoundingClientRect && !(target as MouseEvent).preventDefault) ||\n          document.body.contains(target as Node)\n        ) {\n          currentProps!.gapSpace = offsetFromTarget;\n          const newPositions: IPositionedData = positionElement(\n            currentProps!,\n            hostElement,\n            positioningContainerElement,\n          );\n          // Set the new position only when the positions are not exists or one of the new positioningContainer\n          // positions are different. The position should not change if the position is within 2 decimal places.\n          if (\n            (!positions && newPositions) ||\n            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)\n          ) {\n            // We should not reposition the positioningContainer more than a few times, if it is then the content is\n            // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n            positionAttempts.current++;\n            setPositions(newPositions);\n            onPositioned?.(newPositions);\n          } else {\n            positionAttempts.current = 0;\n            onPositioned?.(newPositions);\n          }\n        } else if (positions !== undefined) {\n          setPositions(undefined);\n        }\n      } else if (positions !== undefined) {\n        setPositions(undefined);\n      }\n    }\n  };\n\n  React.useEffect(updateAsyncPosition);\n\n  return [positions, updateAsyncPosition] as const;\n}\n\nfunction useSetInitialFocus(\n  { setInitialFocus }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n  positions: IPositionedData | undefined,\n) {\n  const didSetInitialFocus = React.useRef(false);\n\n  React.useEffect((): void => {\n    if (!didSetInitialFocus.current && contentHost.current && setInitialFocus && positions) {\n      didSetInitialFocus.current = true;\n      focusFirstChild(contentHost.current);\n    }\n  });\n}\n\nfunction useMaxHeight(\n  { directionalHintFixed, offsetFromTarget, directionalHint, target }: IPositioningContainerProps,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  getCachedBounds: () => IRectangle,\n) {\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going beyond the window or target bounds\n   */\n  const maxHeight = React.useRef<number | undefined>();\n\n  // If the target element changed, reset the max height. If we are tracking\n  // target with class name, always reset because we do not know if\n  // fabric has rendered a new element and disposed the old element.\n  if (typeof target === 'string') {\n    maxHeight.current = undefined;\n  }\n  React.useEffect(() => {\n    maxHeight.current = undefined;\n  }, [target, offsetFromTarget]);\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  const getCachedMaxHeight = (): number => {\n    if (!maxHeight.current) {\n      if (directionalHintFixed && targetRef.current) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        maxHeight.current = getMaxHeight(targetRef.current, directionalHint!, gapSpace, getCachedBounds());\n      } else {\n        maxHeight.current = getCachedBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return maxHeight.current!;\n  };\n\n  return getCachedMaxHeight;\n}\n\nfunction useAutoDismissEvents(\n  { onDismiss, preventDismissOnScroll }: IPositioningContainerProps,\n  positionedHost: React.RefObject<HTMLDivElement | null>,\n  targetWindow: Window | undefined,\n  targetRef: React.RefObject<Element | MouseEvent | Point | null>,\n  positions: IPositionedData | undefined,\n  updateAsyncPosition: () => void,\n) {\n  const async = useAsync();\n\n  const onResize = React.useCallback(\n    (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        updateAsyncPosition();\n      }\n    },\n    [onDismiss, updateAsyncPosition],\n  );\n\n  const dismissOnLostFocus = React.useCallback(\n    (ev: Event): void => {\n      const target = ev.target as HTMLElement;\n      const clickedOutsideCallout = positionedHost.current && !elementContains(positionedHost.current, target);\n\n      if (\n        (!targetRef.current && clickedOutsideCallout) ||\n        (ev.target !== targetWindow &&\n          clickedOutsideCallout &&\n          ((targetRef.current as MouseEvent).stopPropagation ||\n            !targetRef.current ||\n            (target !== targetRef.current && !elementContains(targetRef.current as HTMLElement, target))))\n      ) {\n        onResize(ev);\n      }\n    },\n    [onResize, positionedHost, targetRef, targetWindow],\n  );\n\n  const dismissOnScroll = React.useCallback(\n    (ev: Event): void => {\n      if (positions && !preventDismissOnScroll) {\n        dismissOnLostFocus(ev);\n      }\n    },\n    [dismissOnLostFocus, positions, preventDismissOnScroll],\n  );\n\n  React.useEffect(() => {\n    const events = new EventGroup({});\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    async.setTimeout(() => {\n      events.on(targetWindow, 'scroll', async.throttle(dismissOnScroll, 10), true);\n      events.on(targetWindow, 'resize', async.throttle(onResize, 10), true);\n      events.on(targetWindow?.document?.body, 'focus', dismissOnLostFocus, true);\n      events.on(targetWindow?.document?.body, 'click', dismissOnLostFocus, true);\n    }, 0);\n\n    return () => events.dispose();\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on mount\n  }, [dismissOnScroll]);\n}\n\nexport function useHeightOffset(\n  { finalHeight }: IPositioningContainerProps,\n  contentHost: React.RefObject<HTMLDivElement | null>,\n) {\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n  const [heightOffset, setHeightOffset] = React.useState<number>(0);\n  const async = useAsync();\n  const setHeightOffsetTimer = React.useRef<number>(0);\n\n  /** Animates the height if finalHeight was given. */\n  const setHeightOffsetEveryFrame = (): void => {\n    if (contentHost && finalHeight) {\n      setHeightOffsetTimer.current = async.requestAnimationFrame(() => {\n        if (!contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        setHeightOffset(heightOffset + scrollDiff);\n\n        if (positioningContainerMainElem.offsetHeight < finalHeight) {\n          setHeightOffsetEveryFrame();\n        } else {\n          async.cancelAnimationFrame(setHeightOffsetTimer.current);\n        }\n      });\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only re-run if finalHeight changes\n  React.useEffect(setHeightOffsetEveryFrame, [finalHeight]);\n\n  return heightOffset;\n}\n\nexport const PositioningContainer: React.FunctionComponent<IPositioningContainerProps> = React.forwardRef<\n  HTMLDivElement,\n  IPositioningContainerProps\n>((propsWithoutDefaults, forwardedRef) => {\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n  // @TODO rename to reflect the name of this class\n  const contentHost = React.useRef<HTMLDivElement>(null);\n  /**\n   * The primary positioned div.\n   */\n  const positionedHost = React.useRef<HTMLDivElement>(null);\n  const rootRef = useMergedRefs(forwardedRef, positionedHost);\n\n  const [targetRef, targetWindow] = useTarget(props.target, positionedHost);\n  const getCachedBounds = useCachedBounds(props, targetWindow);\n  const [positions, updateAsyncPosition] = usePositionState(\n    props,\n    positionedHost,\n    contentHost,\n    targetRef,\n    getCachedBounds,\n  );\n  const getCachedMaxHeight = useMaxHeight(props, targetRef, getCachedBounds);\n  const heightOffset = useHeightOffset(props, contentHost);\n\n  useSetInitialFocus(props, contentHost, positions);\n  useAutoDismissEvents(props, positionedHost, targetWindow, targetRef, positions, updateAsyncPosition);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run on initial render\n  React.useEffect(() => props.onLayerMounted?.(), []);\n\n  // If there is no target window then we are likely in server side rendering and we should not render anything.\n  if (!targetWindow) {\n    return null;\n  }\n\n  const { className, doNotLayer, positioningContainerWidth, positioningContainerMaxHeight, children } = props;\n\n  const styles = getClassNames();\n\n  const directionalClassName =\n    positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n  const getContentMaxHeight: number = getCachedMaxHeight() + heightOffset!;\n  const contentMaxHeight: number =\n    positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n      ? getContentMaxHeight\n      : positioningContainerMaxHeight!;\n  const content = (\n    <div ref={rootRef} className={css('ms-PositioningContainer', styles.container)}>\n      <div\n        className={mergeStyles(\n          'ms-PositioningContainer-layerHost',\n          styles.root,\n          className,\n          directionalClassName,\n          !!positioningContainerWidth && { width: positioningContainerWidth },\n          doNotLayer && { zIndex: ZIndexes.Layer },\n        )}\n        style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n        tabIndex={-1}\n        ref={contentHost}\n      >\n        {children}\n        {\n          // @TODO apply to the content container\n          contentMaxHeight\n        }\n      </div>\n    </div>\n  );\n\n  return doNotLayer ? content : <Layer>{content}</Layer>;\n});\nPositioningContainer.displayName = 'PositioningContainer';\n\nfunction arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n  return comparePositions(positions.elementPosition, newPosition.elementPosition);\n}\n\nfunction comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n  for (const key in newPositions) {\n    if (newPositions.hasOwnProperty(key)) {\n      const oldPositionEdge = oldPositions[key];\n      const newPositionEdge = newPositions[key];\n\n      if (oldPositionEdge && newPositionEdge) {\n        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}
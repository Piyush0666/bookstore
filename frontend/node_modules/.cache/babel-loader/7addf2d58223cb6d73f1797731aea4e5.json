{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\n\nvar mountCounters = new WeakMap();\n\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\n\n\nexport function useFocusRects(rootRef) {\n  React.useEffect(function () {\n    var _a;\n\n    var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);\n\n    if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n      return undefined;\n    }\n\n    var count = setMountCounters(win, 1);\n\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return function () {\n      var _a;\n\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\n\nexport var FocusRects = function (props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev) {\n  setFocusVisibility(false, ev.target);\n}\n\nfunction _onPointerDown(ev) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target);\n  }\n}\n\nfunction _onKeyDown(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target);\n  }\n}","map":{"version":3,"mappings":"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","names":["React","getWindow","isDirectionalKeyCode","setFocusVisibility","mountCounters","WeakMap","setMountCounters","key","delta","newValue","currValue","get","set","useFocusRects","rootRef","useEffect","win","current","FabricConfig","_a","disableFocusRects","undefined","count","addEventListener","_onMouseDown","_onPointerDown","_onKeyDown","removeEventListener","FocusRects","props","ev","target","pointerType","which"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\utilities\\src\\useFocusRects.ts"],"sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nlet mountCounters = new WeakMap<Window, number>();\n\nfunction setMountCounters(key: Window, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
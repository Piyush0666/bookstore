{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nimport { useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-hooks';\nvar getClassNames = classNamesFunction();\nvar SVG_REGEX = /\\.svg$/i;\nvar KEY_PREFIX = 'fabricImage';\n\nfunction useLoadState(props, imageElement) {\n  var onLoadingStateChange = props.onLoadingStateChange,\n      onLoad = props.onLoad,\n      onError = props.onError,\n      src = props.src;\n\n  var _a = React.useState(ImageLoadState.notLoaded),\n      loadState = _a[0],\n      setLoadState = _a[1];\n\n  useIsomorphicLayoutEffect(function () {\n    // If the src property changes, reset the load state\n    // (does nothing if the load state is already notLoaded)\n    setLoadState(ImageLoadState.notLoaded);\n  }, [src]); // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render\n\n  React.useEffect(function () {\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;\n\n      if (isLoaded) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    }\n  });\n  React.useEffect(function () {\n    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState); // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes\n  }, [loadState]);\n  var onImageLoaded = React.useCallback(function (ev) {\n    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);\n\n    if (src) {\n      setLoadState(ImageLoadState.loaded);\n    }\n  }, [src, onLoad]);\n  var onImageError = React.useCallback(function (ev) {\n    onError === null || onError === void 0 ? void 0 : onError(ev);\n    setLoadState(ImageLoadState.error);\n  }, [onError]);\n  return [loadState, onImageLoaded, onImageError];\n}\n\nexport var ImageBase = React.forwardRef(function (props, forwardedRef) {\n  var frameElement = React.useRef();\n  var imageElement = React.useRef();\n\n  var _a = useLoadState(props, imageElement),\n      loadState = _a[0],\n      onImageLoaded = _a[1],\n      onImageError = _a[2];\n\n  var imageProps = getNativeProps(props, imgProperties, ['width', 'height']);\n  var src = props.src,\n      alt = props.alt,\n      width = props.width,\n      height = props.height,\n      _b = props.shouldFadeIn,\n      shouldFadeIn = _b === void 0 ? true : _b,\n      shouldStartVisible = props.shouldStartVisible,\n      className = props.className,\n      imageFit = props.imageFit,\n      role = props.role,\n      maximizeFrame = props.maximizeFrame,\n      styles = props.styles,\n      theme = props.theme,\n      loading = props.loading;\n  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);\n  var classNames = getClassNames(styles, {\n    theme: theme,\n    className: className,\n    width: width,\n    height: height,\n    maximizeFrame: maximizeFrame,\n    shouldFadeIn: shouldFadeIn,\n    shouldStartVisible: shouldStartVisible,\n    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,\n    isLandscape: coverStyle === ImageCoverStyle.landscape,\n    isCenter: imageFit === ImageFit.center,\n    isCenterContain: imageFit === ImageFit.centerContain,\n    isCenterCover: imageFit === ImageFit.centerCover,\n    isContain: imageFit === ImageFit.contain,\n    isCover: imageFit === ImageFit.cover,\n    isNone: imageFit === ImageFit.none,\n    isError: loadState === ImageLoadState.error,\n    isNotImageFit: imageFit === undefined\n  }); // If image dimensions aren't specified, the natural size of the image is used.\n\n  return React.createElement(\"div\", {\n    className: classNames.root,\n    style: {\n      width: width,\n      height: height\n    },\n    ref: frameElement\n  }, React.createElement(\"img\", __assign({}, imageProps, {\n    onLoad: onImageLoaded,\n    onError: onImageError,\n    key: KEY_PREFIX + props.src || '',\n    className: classNames.image,\n    ref: useMergedRefs(imageElement, forwardedRef),\n    src: src,\n    alt: alt,\n    role: role,\n    loading: loading\n  })));\n});\nImageBase.displayName = 'ImageBase';\n\nfunction useCoverStyle(props, loadState, imageElement, frameElement) {\n  var previousLoadState = React.useRef(loadState);\n  var coverStyle = React.useRef();\n\n  if (coverStyle === undefined || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {\n    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);\n  }\n\n  previousLoadState.current = loadState;\n  return coverStyle.current;\n}\n\nfunction computeCoverStyle(props, loadState, imageElement, frameElement) {\n  var imageFit = props.imageFit,\n      width = props.width,\n      height = props.height; // Do not compute cover style if it was already specified in props\n\n  if (props.coverStyle !== undefined) {\n    return props.coverStyle;\n  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {\n    // Determine the desired ratio using the width and height props.\n    // If those props aren't available, measure measure the frame.\n    var desiredRatio = void 0;\n\n    if (typeof width === 'number' && typeof height === 'number' && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {\n      desiredRatio = width / height;\n    } else {\n      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;\n    } // Examine the source image to determine its original ratio.\n\n\n    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight; // Should we crop from the top or the sides?\n\n    if (naturalRatio > desiredRatio) {\n      return ImageCoverStyle.landscape;\n    }\n  }\n\n  return ImageCoverStyle.portrait;\n}","map":{"version":3,"mappings":"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","names":["React","classNamesFunction","getNativeProps","imgProperties","ImageCoverStyle","ImageFit","ImageLoadState","useIsomorphicLayoutEffect","useMergedRefs","getClassNames","SVG_REGEX","KEY_PREFIX","useLoadState","props","imageElement","onLoad","onError","src","useState","notLoaded","loadState","setLoadState","useEffect","isLoaded","current","naturalWidth","naturalHeight","complete","test","loaded","onLoadingStateChange","onImageLoaded","useCallback","ev","onImageError","error","ImageBase","forwardRef","forwardedRef","frameElement","useRef","imageProps","alt","width","height","_b","shouldFadeIn","shouldStartVisible","className","imageFit","role","maximizeFrame","styles","theme","loading","coverStyle","useCoverStyle","classNames","isLandscape","landscape","isCenter","center","isCenterContain","centerContain","isCenterCover","centerCover","isContain","contain","isCover","cover","isNone","none","isError","isNotImageFit","undefined","root","style","ref","key","image","displayName","previousLoadState","computeCoverStyle","desiredRatio","clientWidth","clientHeight","naturalRatio","portrait"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\Image\\Image.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nimport { useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-hooks';\nimport type { IImageProps, IImageStyleProps, IImageStyles } from './Image.types';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst SVG_REGEX = /\\.svg$/i;\nconst KEY_PREFIX = 'fabricImage';\n\nfunction useLoadState(\n  props: IImageProps,\n  imageElement: React.RefObject<HTMLImageElement>,\n): readonly [\n  ImageLoadState,\n  /* onImageLoad */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n  /* onImageError */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n] {\n  const { onLoadingStateChange, onLoad, onError, src } = props;\n\n  const [loadState, setLoadState] = React.useState<ImageLoadState>(ImageLoadState.notLoaded);\n\n  useIsomorphicLayoutEffect(() => {\n    // If the src property changes, reset the load state\n    // (does nothing if the load state is already notLoaded)\n    setLoadState(ImageLoadState.notLoaded);\n  }, [src]);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render\n  React.useEffect(() => {\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = imageElement.current\n        ? (src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0) ||\n          (imageElement.current.complete && SVG_REGEX.test(src!))\n        : false;\n\n      if (isLoaded) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    }\n  });\n\n  React.useEffect(() => {\n    onLoadingStateChange?.(loadState);\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes\n  }, [loadState]);\n\n  const onImageLoaded = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onLoad?.(ev);\n      if (src) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    },\n    [src, onLoad],\n  );\n\n  const onImageError = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onError?.(ev);\n      setLoadState(ImageLoadState.error);\n    },\n    [onError],\n  );\n\n  return [loadState, onImageLoaded, onImageError] as const;\n}\n\nexport const ImageBase: React.FunctionComponent<IImageProps> = React.forwardRef<HTMLImageElement, IImageProps>(\n  (props, forwardedRef) => {\n    const frameElement = React.useRef<HTMLDivElement>() as React.RefObject<HTMLDivElement>;\n    const imageElement = React.useRef<HTMLImageElement>() as React.RefObject<HTMLImageElement>;\n    const [loadState, onImageLoaded, onImageError] = useLoadState(props, imageElement);\n\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(props, imgProperties, [\n      'width',\n      'height',\n    ]);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn = true,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme,\n      loading,\n    } = props;\n    const coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded:\n        loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined,\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={frameElement}>\n        <img\n          {...imageProps}\n          onLoad={onImageLoaded}\n          onError={onImageError}\n          key={KEY_PREFIX + props.src || ''}\n          className={classNames.image}\n          ref={useMergedRefs(imageElement, forwardedRef)}\n          src={src}\n          alt={alt}\n          role={role}\n          loading={loading}\n        />\n      </div>\n    );\n  },\n);\nImageBase.displayName = 'ImageBase';\n\nfunction useCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n) {\n  const previousLoadState = React.useRef(loadState);\n  const coverStyle = React.useRef<ImageCoverStyle | undefined>();\n\n  if (\n    coverStyle === undefined ||\n    (previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded)\n  ) {\n    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);\n  }\n\n  previousLoadState.current = loadState;\n\n  return coverStyle.current!;\n}\n\nfunction computeCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n): ImageCoverStyle {\n  const { imageFit, width, height } = props;\n\n  // Do not compute cover style if it was already specified in props\n  if (props.coverStyle !== undefined) {\n    return props.coverStyle;\n  } else if (\n    loadState === ImageLoadState.loaded &&\n    (imageFit === ImageFit.cover ||\n      imageFit === ImageFit.contain ||\n      imageFit === ImageFit.centerContain ||\n      imageFit === ImageFit.centerCover) &&\n    imageElement.current &&\n    frameElement.current\n  ) {\n    // Determine the desired ratio using the width and height props.\n    // If those props aren't available, measure measure the frame.\n    let desiredRatio;\n    if (\n      typeof width === 'number' &&\n      typeof height === 'number' &&\n      imageFit !== ImageFit.centerContain &&\n      imageFit !== ImageFit.centerCover\n    ) {\n      desiredRatio = width / height;\n    } else {\n      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;\n    }\n\n    // Examine the source image to determine its original ratio.\n    const naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;\n\n    // Should we crop from the top or the sides?\n    if (naturalRatio > desiredRatio) {\n      return ImageCoverStyle.landscape;\n    }\n  }\n  return ImageCoverStyle.portrait;\n}\n"]},"metadata":{},"sourceType":"module"}
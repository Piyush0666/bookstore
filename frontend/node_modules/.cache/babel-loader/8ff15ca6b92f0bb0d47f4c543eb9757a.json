{"ast":null,"code":"import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\n\nexport var useOverflow = function (_a) {\n  var onOverflowItemsChanged = _a.onOverflowItemsChanged,\n      rtl = _a.rtl,\n      pinnedIndex = _a.pinnedIndex;\n  var updateOverflowRef = React.useRef();\n  var containerWidthRef = React.useRef(); // Attach a resize observer to the container\n\n  var containerRef = useRefEffect(function (container) {\n    var cleanupObserver = observeResize(container, function (entries) {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n    return function () {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n  var menuButtonRef = useRefEffect(function (menuButton) {\n    containerRef(menuButton.parentElement);\n    return function () {\n      return containerRef(null);\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    var menuButton = menuButtonRef.current;\n\n    if (!container || !menuButton) {\n      return;\n    } // items contains the container's children, excluding the overflow menu button itself\n\n\n    var items = [];\n\n    for (var i = 0; i < container.children.length; i++) {\n      var item = container.children[i];\n\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    } // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n\n\n    var minContainerWidth = [];\n    var extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = function () {\n      var containerWidth = containerWidthRef.current;\n\n      if (containerWidth === undefined) {\n        return;\n      } // Iterate the items in reverse order until we find one that fits within the bounds of the container\n\n\n      for (var i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          var itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth; // If the item after this one is pinned, reserve space for it\n\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          } // Reserve space for the menu button after the first item was added to the overflow\n\n\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      } // If we got here, nothing fits outside the overflow\n\n\n      setOverflowIndex(0);\n    };\n\n    var prevOverflowIndex = items.length;\n\n    var setOverflowIndex = function (overflowIndex) {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(overflowIndex, items.map(function (ele, index) {\n          return {\n            ele: ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex\n          };\n        }));\n      }\n    };\n\n    var cancelAnimationFrame = undefined; // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n\n    if (containerWidthRef.current !== undefined) {\n      var win_1 = getWindow(container);\n\n      if (win_1) {\n        var animationFrameId_1 = win_1.requestAnimationFrame(updateOverflowRef.current);\n\n        cancelAnimationFrame = function () {\n          return win_1.cancelAnimationFrame(animationFrameId_1);\n        };\n      }\n    }\n\n    return function () {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      } // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n\n\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n  return {\n    menuButtonRef: menuButtonRef\n  };\n};","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,yBAAT,EAAoCC,YAApC,QAAwD,uBAAxD;AACA,SAASC,SAAT,QAA0B,qBAA1B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AAiCA;;;;;;;;;;;;;;;;;;;AAkBA,OAAO,IAAMC,WAAW,GAAG,UAACC,EAAD,EAA6D;MAA1DC,sBAAsB;MAAEC,GAAG;MAAEC,WAAW;EACpE,IAAMC,iBAAiB,GAAGV,KAAK,CAACW,MAAN,EAA1B;EACA,IAAMC,iBAAiB,GAAGZ,KAAK,CAACW,MAAN,EAA1B,CAFsF,CAItF;;EACA,IAAME,YAAY,GAAGX,YAAY,CAAc,qBAAS;IACtD,IAAMY,eAAe,GAAGV,aAAa,CAACW,SAAD,EAAY,mBAAO;MACtDH,iBAAiB,CAACI,OAAlB,GAA4BC,OAAO,GAAGA,OAAO,CAAC,CAAD,CAAP,CAAWC,WAAX,CAAuBC,KAA1B,GAAkCJ,SAAS,CAACK,WAA/E;;MACA,IAAIV,iBAAiB,CAACM,OAAtB,EAA+B;QAC7BN,iBAAiB,CAACM,OAAlB;MACD;IACF,CALoC,CAArC;IAOA,OAAO;MACLF,eAAe;MACfF,iBAAiB,CAACI,OAAlB,GAA4BK,SAA5B;IACD,CAHD;EAID,CAZgC,CAAjC;EAcA,IAAMC,aAAa,GAAGpB,YAAY,CAAc,sBAAU;IACxDW,YAAY,CAACU,UAAU,CAACC,aAAZ,CAAZ;IACA,OAAO;MAAM,mBAAY,CAAC,IAAD,CAAZ;IAAkB,CAA/B;EACD,CAHiC,CAAlC;EAKAvB,yBAAyB,CAAC;IACxB,IAAMc,SAAS,GAAGF,YAAY,CAACG,OAA/B;IACA,IAAMO,UAAU,GAAGD,aAAa,CAACN,OAAjC;;IACA,IAAI,CAACD,SAAD,IAAc,CAACQ,UAAnB,EAA+B;MAC7B;IACD,CALuB,CAOxB;;;IACA,IAAME,KAAK,GAAkB,EAA7B;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,SAAS,CAACY,QAAV,CAAmBC,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;MAClD,IAAMG,IAAI,GAAGd,SAAS,CAACY,QAAV,CAAmBD,CAAnB,CAAb;;MACA,IAAIG,IAAI,YAAYC,WAAhB,IAA+BD,IAAI,KAAKN,UAA5C,EAAwD;QACtDE,KAAK,CAACM,IAAN,CAAWF,IAAX;MACD;IACF,CAduB,CAgBxB;IACA;IACA;;;IACA,IAAMG,iBAAiB,GAAa,EAApC;IACA,IAAIC,UAAU,GAAG,CAAjB,CApBwB,CAoBJ;;IAEpBvB,iBAAiB,CAACM,OAAlB,GAA4B;MAC1B,IAAMkB,cAAc,GAAGtB,iBAAiB,CAACI,OAAzC;;MACA,IAAIkB,cAAc,KAAKb,SAAvB,EAAkC;QAChC;MACD,CAJyB,CAM1B;;;MACA,KAAK,IAAIK,CAAC,GAAGD,KAAK,CAACG,MAAN,GAAe,CAA5B,EAA+BF,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;QAC1C;QACA,IAAIM,iBAAiB,CAACN,CAAD,CAAjB,KAAyBL,SAA7B,EAAwC;UACtC,IAAMc,aAAa,GAAG3B,GAAG,GAAG0B,cAAc,GAAGT,KAAK,CAACC,CAAD,CAAL,CAASU,UAA7B,GAA0CX,KAAK,CAACC,CAAD,CAAL,CAASU,UAAT,GAAsBX,KAAK,CAACC,CAAD,CAAL,CAASW,WAAlG,CADsC,CAGtC;;UACA,IAAIX,CAAC,GAAG,CAAJ,GAAQD,KAAK,CAACG,MAAd,IAAwBF,CAAC,GAAG,CAAJ,KAAUjB,WAAtC,EAAmD;YACjD;YACA;YACAwB,UAAU,GAAGD,iBAAiB,CAACN,CAAC,GAAG,CAAL,CAAjB,GAA2BS,aAAxC;UACD,CARqC,CAUtC;;;UACA,IAAIT,CAAC,KAAKD,KAAK,CAACG,MAAN,GAAe,CAAzB,EAA4B;YAC1BK,UAAU,IAAIV,UAAU,CAACc,WAAzB;UACD;;UAEDL,iBAAiB,CAACN,CAAD,CAAjB,GAAuBS,aAAa,GAAGF,UAAvC;QACD;;QAED,IAAIC,cAAc,GAAGF,iBAAiB,CAACN,CAAD,CAAtC,EAA2C;UACzCY,gBAAgB,CAACZ,CAAC,GAAG,CAAL,CAAhB;UACA;QACD;MACF,CA/ByB,CAiC1B;;;MACAY,gBAAgB,CAAC,CAAD,CAAhB;IACD,CAnCD;;IAqCA,IAAIC,iBAAiB,GAAGd,KAAK,CAACG,MAA9B;;IACA,IAAMU,gBAAgB,GAAG,UAACE,aAAD,EAAsB;MAC7C,IAAID,iBAAiB,KAAKC,aAA1B,EAAyC;QACvCD,iBAAiB,GAAGC,aAApB;QACAjC,sBAAsB,CACpBiC,aADoB,EAEpBf,KAAK,CAACgB,GAAN,CAAU,UAACC,GAAD,EAAMC,KAAN,EAAW;UAAK,OAAC;YACzBD,GAAG,KADsB;YAEzBE,aAAa,EAAED,KAAK,IAAIH,aAAT,IAA0BG,KAAK,KAAKlC;UAF1B,CAAD;QAGxB,CAHF,CAFoB,CAAtB;MAOD;IACF,CAXD;;IAaA,IAAIoC,oBAAoB,GAA6BxB,SAArD,CAzEwB,CA2ExB;IACA;;IACA,IAAIT,iBAAiB,CAACI,OAAlB,KAA8BK,SAAlC,EAA6C;MAC3C,IAAMyB,KAAG,GAAG3C,SAAS,CAACY,SAAD,CAArB;;MACA,IAAI+B,KAAJ,EAAS;QACP,IAAMC,kBAAgB,GAAGD,KAAG,CAACE,qBAAJ,CAA0BtC,iBAAiB,CAACM,OAA5C,CAAzB;;QACA6B,oBAAoB,GAAG;UAAM,YAAG,CAACA,oBAAJ,CAAyBE,kBAAzB;QAA0C,CAAvE;MACD;IACF;;IAED,OAAO;MACL,IAAIF,oBAAJ,EAA0B;QACxBA,oBAAoB;MACrB,CAHI,CAKL;MACA;;;MACAP,gBAAgB,CAACb,KAAK,CAACG,MAAP,CAAhB;MACAlB,iBAAiB,CAACM,OAAlB,GAA4BK,SAA5B;IACD,CATD;EAUD,CA/FwB,CAAzB;EAiGA,OAAO;IAAEC,aAAa;EAAf,CAAP;AACD,CA1HM","names":["React","useIsomorphicLayoutEffect","useRefEffect","getWindow","observeResize","useOverflow","_a","onOverflowItemsChanged","rtl","pinnedIndex","updateOverflowRef","useRef","containerWidthRef","containerRef","cleanupObserver","container","current","entries","contentRect","width","clientWidth","undefined","menuButtonRef","menuButton","parentElement","items","i","children","length","item","HTMLElement","push","minContainerWidth","extraWidth","containerWidth","itemOffsetEnd","offsetLeft","offsetWidth","setOverflowIndex","prevOverflowIndex","overflowIndex","map","ele","index","isOverflowing","cancelAnimationFrame","win_1","animationFrameId_1","requestAnimationFrame"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\src\\utilities\\useOverflow.ts"],"sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { concatStyleSetsWithProps } from '@fluentui/merge-styles';\nimport { useCustomizationSettings } from './customizations/useCustomizationSettings';\nvar DefaultFields = ['theme', 'styles'];\nexport function styled(Component, baseStyles, getProps, customizable, pure) {\n  customizable = customizable || {\n    scope: '',\n    fields: undefined\n  };\n  var scope = customizable.scope,\n      _a = customizable.fields,\n      fields = _a === void 0 ? DefaultFields : _a;\n  var Wrapped = React.forwardRef(function (props, forwardedRef) {\n    var styles = React.useRef();\n    var settings = useCustomizationSettings(fields, scope);\n\n    var customizedStyles = settings.styles,\n        dir = settings.dir,\n        rest = __rest(settings, [\"styles\", \"dir\"]);\n\n    var additionalProps = getProps ? getProps(props) : undefined; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var cache = styles.current && styles.current.__cachedInputs__ || [];\n    var propStyles = props.styles;\n\n    if (!styles.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {\n      // Using styled components as the Component arg will result in nested styling arrays.\n      // The function can be cached and in order to prevent the props from being retained within it's closure\n      // we pass in just the styles and not the entire props\n      var concatenatedStyles = function (styleProps) {\n        return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);\n      }; // The __cachedInputs__ array is attached to the function and consumed by the\n      // classNamesFunction as a list of keys to include for memoizing classnames.\n\n\n      concatenatedStyles.__cachedInputs__ = [baseStyles, customizedStyles, propStyles];\n      concatenatedStyles.__noStyleOverride__ = !customizedStyles && !propStyles;\n      styles.current = concatenatedStyles;\n    }\n\n    return React.createElement(Component, __assign({\n      ref: forwardedRef\n    }, rest, additionalProps, props, {\n      styles: styles.current\n    }));\n  }); // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n  // able to drop IE 11 support and compile with ES6 libs\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  Wrapped.displayName = \"Styled\" + (Component.displayName || Component.name); // This preserves backwards compatibility.\n\n  var pureComponent = pure ? React.memo(Wrapped) : Wrapped; // Check if the wrapper has a displayName after it has been memoized. Then assign it to the pure component.\n\n  if (Wrapped.displayName) {\n    pureComponent.displayName = Wrapped.displayName;\n  }\n\n  return pureComponent;\n}","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,wBAAT,QAAyC,wBAAzC;AACA,SAASC,wBAAT,QAAyC,2CAAzC;AAoBA,IAAMC,aAAa,GAAG,CAAC,OAAD,EAAU,QAAV,CAAtB;AAoDA,OAAM,SAAUC,MAAV,CAMJC,SANI,EAOJC,UAPI,EAQJC,QARI,EASJC,YATI,EAUJC,IAVI,EAUU;EAEdD,YAAY,GAAGA,YAAY,IAAI;IAAEE,KAAK,EAAE,EAAT;IAAaC,MAAM,EAAEC;EAArB,CAA/B;EAEQ,SAAK,GAA6BJ,YAAY,MAA9C;EAAA,IAAOK,KAA2BL,YAAY,OAA9C;EAAA,IAAOG,MAAM,mBAAGR,aAAH,GAAgBU,EAA7B;EAER,IAAMC,OAAO,GAAGd,KAAK,CAACe,UAAN,CAAiB,UAACC,KAAD,EAAyBC,YAAzB,EAAsD;IACrF,IAAMC,MAAM,GAAGlB,KAAK,CAACmB,MAAN,EAAf;IAEA,IAAMC,QAAQ,GAAGlB,wBAAwB,CAACS,MAAD,EAASD,KAAT,CAAzC;;IACQ,IAAQW,gBAAgB,GAAmBD,QAAQ,OAAnD;IAAA,IAA0BE,GAAG,GAAcF,QAAQ,IAAnD;IAAA,IAAkCG,IAAI,UAAKH,QAAL,EAAxC,iBAAwC,CAAtC;;IACR,IAAMI,eAAe,GAAGjB,QAAQ,GAAGA,QAAQ,CAACS,KAAD,CAAX,GAAqBJ,SAArD,CALqF,CAOrF;;IACA,IAAMa,KAAK,GAAIP,MAAM,CAACQ,OAAP,IAAmBR,MAAM,CAACQ,OAAP,CAAuBC,gBAA3C,IAAgE,EAA9E;IACA,IAAMC,UAAU,GAAGZ,KAAK,CAACE,MAAzB;;IACA,IAAI,CAACA,MAAM,CAACQ,OAAR,IAAmBL,gBAAgB,KAAKI,KAAK,CAAC,CAAD,CAA7C,IAAoDG,UAAU,KAAKH,KAAK,CAAC,CAAD,CAA5E,EAAiF;MAC/E;MACA;MACA;MACA,IAAMI,kBAAkB,GAAmD,UAACC,UAAD,EAAwB;QACjG,+BAAwB,CAACA,UAAD,EAAaxB,UAAb,EAAyBe,gBAAzB,EAA2CO,UAA3C,CAAxB;MAA8E,CADhF,CAJ+E,CAO/E;MACA;;;MACCC,kBAA4D,CAACF,gBAA7D,GAAgF,CAC/ErB,UAD+E,EAE/Ee,gBAF+E,EAG/EO,UAH+E,CAAhF;MAMAC,kBAA4D,CAACE,mBAA7D,GACC,CAACV,gBAAD,IAAqB,CAACO,UADvB;MAGDV,MAAM,CAACQ,OAAP,GAAiBG,kBAAjB;IACD;;IAED,OAAO7B,oBAACK,SAAD,EAAU2B;MAACC,GAAG,EAAEhB;IAAN,GAAwBM,IAAxB,EAAkCC,eAAlC,EAAuDR,KAAvD,EAA4D;MAAEE,MAAM,EAAEA,MAAM,CAACQ;IAAjB,CAA5D,CAAV,CAAP;EACD,CAhCe,CAAhB,CANc,CAuCd;EACA;EACA;;EACAZ,OAAO,CAACoB,WAAR,GAAsB,YAAS7B,SAAS,CAAC6B,WAAV,IAA0B7B,SAAiB,CAAC8B,IAArD,CAAtB,CA1Cc,CA4Cd;;EACA,IAAMC,aAAa,GAAG3B,IAAI,GAAGT,KAAK,CAACqC,IAAN,CAAWvB,OAAX,CAAH,GAAyBA,OAAnD,CA7Cc,CA8Cd;;EACA,IAAIA,OAAO,CAACoB,WAAZ,EAAyB;IACvBE,aAAa,CAACF,WAAd,GAA4BpB,OAAO,CAACoB,WAApC;EACD;;EAED,OAAOE,aAAP;AACD","names":["React","concatStyleSetsWithProps","useCustomizationSettings","DefaultFields","styled","Component","baseStyles","getProps","customizable","pure","scope","fields","undefined","_a","Wrapped","forwardRef","props","forwardedRef","styles","useRef","settings","customizedStyles","dir","rest","additionalProps","cache","current","__cachedInputs__","propStyles","concatenatedStyles","styleProps","__noStyleOverride__","__assign","ref","displayName","name","pureComponent","memo"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\utilities\\src\\styled.tsx"],"sourcesContent":["import * as React from 'react';\nimport { concatStyleSetsWithProps } from '@fluentui/merge-styles';\nimport { useCustomizationSettings } from './customizations/useCustomizationSettings';\nimport type { IStyleSet, IStyleFunctionOrObject } from '@fluentui/merge-styles';\n\nexport interface IPropsWithStyles<TStyleProps, TStyleSet extends IStyleSet<TStyleSet>> {\n  styles?: IStyleFunctionOrObject<TStyleProps, TStyleSet>;\n}\n\nexport interface ICustomizableProps {\n  /**\n   * Name of scope, which can be targeted using the Customizer.\n   */\n  scope: string;\n\n  /**\n   * List of fields which can be customized.\n   * @defaultvalue [ 'theme', 'styles' ]\n   */\n  fields?: string[];\n}\n\nconst DefaultFields = ['theme', 'styles'];\n\nexport type StyleFunction<TStyleProps, TStyleSet> = IStyleFunctionOrObject<TStyleProps, TStyleSet> & {\n  /** Cache for all style functions. */\n  __cachedInputs__: (IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined)[];\n\n  /** True if no styles prop or styles from Customizer is passed to wrapped component. */\n  __noStyleOverride__: boolean;\n};\n\n/**\n * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve\n * getStyles functional props, and mix customized props passed in using concatStyleSets.\n *\n * @example\n * ```tsx\n * export const Toggle = styled(\n *   ToggleBase,\n *   props => ({ root: { background: 'red' }})\n * );\n * ```\n * @param Component - The unstyled base component to render, which receives styles.\n * @param baseStyles - The styles which should be curried with the component.\n * @param getProps - A helper which provides default props.\n * @param customizable - An object which defines which props can be customized using the Customizer.\n * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.\n * Note that pure should not be used on components which allow children, or take in complex objects or\n * arrays as props which could mutate on every render.\n */\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet>,\n  TStyleProps,\n  TStyleSet extends IStyleSet<TStyleSet>\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n): React.FunctionComponent<TComponentProps>;\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet> & React.RefAttributes<TRef>,\n  TStyleProps,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TRef = unknown\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n): React.ForwardRefExoticComponent<React.PropsWithoutRef<TComponentProps> & React.RefAttributes<TRef>>;\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet> & React.RefAttributes<TRef>,\n  TStyleProps,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TRef = unknown\n>(\n  Component: React.ComponentClass<TComponentProps> | React.FunctionComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean,\n) {\n  customizable = customizable || { scope: '', fields: undefined };\n\n  const { scope, fields = DefaultFields } = customizable;\n\n  const Wrapped = React.forwardRef((props: TComponentProps, forwardedRef: React.Ref<TRef>) => {\n    const styles = React.useRef<StyleFunction<TStyleProps, TStyleSet>>();\n\n    const settings = useCustomizationSettings(fields, scope);\n    const { styles: customizedStyles, dir, ...rest } = settings;\n    const additionalProps = getProps ? getProps(props) : undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const cache = (styles.current && (styles.current as any).__cachedInputs__) || [];\n    const propStyles = props.styles;\n    if (!styles.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {\n      // Using styled components as the Component arg will result in nested styling arrays.\n      // The function can be cached and in order to prevent the props from being retained within it's closure\n      // we pass in just the styles and not the entire props\n      const concatenatedStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> = (styleProps: TStyleProps) =>\n        concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);\n\n      // The __cachedInputs__ array is attached to the function and consumed by the\n      // classNamesFunction as a list of keys to include for memoizing classnames.\n      (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__cachedInputs__ = [\n        baseStyles,\n        customizedStyles,\n        propStyles,\n      ];\n\n      (concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__ =\n        !customizedStyles && !propStyles;\n\n      styles.current = concatenatedStyles as StyleFunction<TStyleProps, TStyleSet>;\n    }\n\n    return <Component ref={forwardedRef} {...rest} {...additionalProps} {...props} styles={styles.current} />;\n  });\n  // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n  // able to drop IE 11 support and compile with ES6 libs\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Wrapped.displayName = `Styled${Component.displayName || (Component as any).name}`;\n\n  // This preserves backwards compatibility.\n  const pureComponent = pure ? React.memo(Wrapped) : Wrapped;\n  // Check if the wrapper has a displayName after it has been memoized. Then assign it to the pure component.\n  if (Wrapped.displayName) {\n    pureComponent.displayName = Wrapped.displayName;\n  }\n\n  return pureComponent;\n}\n"]},"metadata":{},"sourceType":"module"}
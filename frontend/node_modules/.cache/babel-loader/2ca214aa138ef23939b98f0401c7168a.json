{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\n\nvar ScrollablePaneBase =\n/** @class */\nfunction (_super) {\n  __extends(ScrollablePaneBase, _super);\n\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky); // If ScrollablePane is mounted, then sort sticky in correct place\n\n\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n\n        _this.sortSticky(sticky);\n      }\n    };\n\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n\n      _this._removeStickyFromContainers(sticky);\n\n      _this.notifySubscribers();\n    };\n\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n            isStickyTop = _a.isStickyTop,\n            isStickyBottom = _a.isStickyBottom;\n\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          _this._checkStickyStatus(sticky);\n        }\n      });\n\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n\n      return 0;\n    };\n\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = []; // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n\n            return false;\n          }); // Get first element that has a distance from top that is further than our sticky that is being added\n\n          var targetStickyToAppendBefore = undefined;\n\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          } // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n\n\n          var targetContainer = null;\n\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n\n      var scrollbarHeight = _this._getScrollbarHeight();\n\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n\n      _this.notifySubscribers();\n    };\n\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      } : {\n        left: '0',\n        right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + \"px\"\n      });\n    };\n\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n\n      _this._notifyThrottled();\n    };\n\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function () {\n      return this._root.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function () {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function () {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function () {\n      return this._contentContainer.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n\n    this._events.on(window, 'resize', this._onWindowResize);\n\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Set sticky distances from top property, then sort in correct order and notify subscribers\n\n\n    this.setStickiesDistanceFromTop();\n\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n\n          return false;\n        } // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n\n\n        var scrollbarHeight = _this._getScrollbarHeight(); // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n\n\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        } // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n\n\n        _this.notifySubscribers(); // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n\n\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }; // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n\n\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n\n\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        scrollContainerFocus = _a.scrollContainerFocus,\n        scrollContainerAriaLabel = _a.scrollContainerAriaLabel,\n        theme = _a.theme,\n        styles = _a.styles,\n        onScroll = _a.onScroll;\n    var _b = this.state,\n        stickyTopHeight = _b.stickyTopHeight,\n        stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    var scrollContainerProps = scrollContainerFocus ? {\n      role: 'group',\n      tabIndex: 0,\n      'aria-label': scrollContainerAriaLabel,\n      onScroll: onScroll\n    } : {\n      onScroll: onScroll\n    };\n    return React.createElement(\"div\", __assign({}, getNativeProps(__assign({}, this.props), divProperties, // on React 17 onScroll is not being invoked on root element,\n    // as a fix this method will be provided to the container element\n    ['onScroll']), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", __assign({\n      ref: this._contentContainer\n    }, scrollContainerProps, {\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }), React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n\n  return ScrollablePaneBase;\n}(React.Component);\n\nexport { ScrollablePaneBase };","map":{"version":3,"mappings":"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","names":["React","Async","EventGroup","classNamesFunction","divProperties","getNativeProps","getRTL","initializeComponentRef","ScrollablePaneContext","getClassNames","__extends","props","_super","_this","createRef","handler","_subscribers","add","delete","sticky","_stickies","contentContainer","setDistanceFromTop","sortSticky","_removeStickyFromContainers","notifySubscribers","sortAgain","stickyAbove","stickyBelow","canStickyTop","stickyContentTop","_addToStickyContainer","canStickyBottom","stickyContentBottom","stickyItems","stickyTopHeight","stickyBottomHeight","forEach","state","isStickyTop","isStickyBottom","nonStickyContent","offsetHeight","_checkStickyStatus","setState","handle","scrollTop","syncScroll","scrollablePane","subscribe","unsubscribe","addSticky","removeSticky","updateStickyRefHeights","syncScrollSticky","stickyContainer","stickyContentToAdd","children","length","appendChild","contains","stickyChildrenElements_1","slice","call","stickyList_1","push","stickyItem","stickyListSorted","sort","a","b","distanceFromTop","filter","stickyContent","item","indexOf","targetStickyToAppendBefore","undefined","_i","stickyListItem","targetContainer","insertBefore","removeChild","scrollbarWidth","_getScrollbarWidth","scrollbarHeight","_getScrollbarHeight","height","isTop","theme","right","left","top","bottom","_notifyThrottled","Set","_async","_events","throttle","Object","ScrollablePaneBase","_root","current","_stickyAboveRef","_stickyBelowRef","_contentContainer","initialScrollPosition","on","_onScroll","window","_onWindowResize","setStickiesDistanceFromTop","_mutationObserver","MutationObserver","checkIfMutationIsSticky","mutationRecord","target","mutation","some","bind","stickyList_2","root","forceUpdate","observe","childList","attributes","subtree","characterData","dispose","disconnect","nextProps","nextState","className","prevProps","prevState","setTimeout","scrollContainerFocus","scrollContainerAriaLabel","styles","onScroll","classNames","scrollbarVisibility","scrollContainerProps","role","tabIndex","ref","style","_getStickyContainerStyle","Provider","value","_getScrollablePaneContext","stickyBelowItems","resetSticky","offsetWidth","clientWidth","clientHeight","Component"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\ScrollablePane\\ScrollablePane.base.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\nimport type {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n} from './ScrollablePane.types';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase\n  extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane {\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight: scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, scrollContainerFocus, scrollContainerAriaLabel, theme, styles, onScroll } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    const scrollContainerProps = scrollContainerFocus\n      ? {\n          role: 'group',\n          tabIndex: 0,\n          'aria-label': scrollContainerAriaLabel,\n          onScroll,\n        }\n      : {\n          onScroll,\n        };\n\n    return (\n      <div\n        {...getNativeProps(\n          {\n            ...this.props,\n          },\n          divProperties,\n          // on React 17 onScroll is not being invoked on root element,\n          // as a fix this method will be provided to the container element\n          ['onScroll'],\n        )}\n        ref={this._root}\n        className={classNames.root}\n      >\n        <div\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div\n          ref={this._contentContainer}\n          {...scrollContainerProps}\n          className={classNames.contentContainer}\n          data-is-scrollable={true}\n        >\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div className={classNames.stickyBelow} style={this._getStickyContainerStyle(stickyBottomHeight, false)}>\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight: stickyTopHeight,\n      stickyBottomHeight: stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height: height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"]},"metadata":{},"sourceType":"module"}
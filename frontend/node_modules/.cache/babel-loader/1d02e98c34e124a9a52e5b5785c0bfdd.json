{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync, getPropsWithDefaults, modalize, on } from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useEventCallback, usePrevious, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nvar COMPONENT_NAME = 'FocusTrapZone';\nvar DEFAULT_PROPS = {\n  disabled: false,\n  disableFirstFocus: false,\n  forceFocusInsideTrap: true,\n  isClickableOutsideFocusTrap: false\n};\n\nvar useComponentRef = function (componentRef, previouslyFocusedElement, focusFTZ) {\n  React.useImperativeHandle(componentRef, function () {\n    return {\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n\n      focus: focusFTZ\n    };\n  }, [focusFTZ, previouslyFocusedElement]);\n};\n\nexport var FocusTrapZone = React.forwardRef(function (propsWithoutDefaults, ref) {\n  var _a;\n\n  var root = React.useRef(null);\n  var firstBumper = React.useRef(null);\n  var lastBumper = React.useRef(null);\n  var mergedRootRef = useMergedRefs(root, ref);\n  var doc = useDocument();\n  var isFirstRender = (_a = usePrevious(false)) !== null && _a !== void 0 ? _a : true;\n  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n  var internalState = useConst({\n    hasFocus: false,\n    focusStackId: useId('ftz-', props.id)\n  });\n  var children = props.children,\n      componentRef = props.componentRef,\n      disabled = props.disabled,\n      disableFirstFocus = props.disableFirstFocus,\n      forceFocusInsideTrap = props.forceFocusInsideTrap,\n      focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement,\n      // eslint-disable-next-line deprecation/deprecation\n  firstFocusableSelector = props.firstFocusableSelector,\n      firstFocusableTarget = props.firstFocusableTarget,\n      // eslint-disable-next-line deprecation/deprecation\n  _b = props.disableRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n  disableRestoreFocus = _b === void 0 ? props.ignoreExternalFocusing : _b,\n      isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap,\n      enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;\n  var bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n\n    },\n    tabIndex: disabled ? -1 : 0,\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true\n  };\n  var focusElementAsync = React.useCallback(function (element) {\n    if (element !== firstBumper.current && element !== lastBumper.current) {\n      focusAsync(element);\n    }\n  }, []);\n  /**\n   * Callback to force focus into FTZ (named to avoid overlap with global focus() callback).\n   * useEventCallback always returns the same callback reference but updates the implementation\n   * every render to avoid stale captured values.\n   */\n\n  var focusFTZ = useEventCallback(function () {\n    if (!root.current) {\n      return; // not done mounting\n    }\n\n    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;\n\n    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root.current, previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusElementAsync(previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    var firstFocusableChild = null;\n\n    if (typeof firstFocusableTarget === 'string') {\n      firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n    } else if (firstFocusableTarget) {\n      firstFocusableChild = firstFocusableTarget(root.current);\n    } else if (firstFocusableSelector) {\n      var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector();\n      firstFocusableChild = root.current.querySelector('.' + focusSelector);\n    } // Fall back to first element if query selector did not match any elements.\n\n\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(root.current, root.current.firstChild, false, false, false, true);\n    }\n\n    if (firstFocusableChild) {\n      focusElementAsync(firstFocusableChild);\n    }\n  });\n  /** Used in root div focus/blur handlers */\n\n  var focusBumper = function (isFirstBumper) {\n    if (disabled || !root.current) {\n      return;\n    }\n\n    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root.current, lastBumper.current, true, false) : getFirstTabbable(root.current, firstBumper.current, true, false);\n\n    if (nextFocusable) {\n      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n        // This can happen when FTZ contains no tabbable elements.\n        // focusFTZ() will take care of finding a focusable element in FTZ.\n        focusFTZ();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n  /** Root div blur handler (doesn't need useCallback since it's for a native element) */\n\n\n  var onRootBlurCapture = function (ev) {\n    var _a;\n\n    (_a = props.onBlurCapture) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n    var relatedTarget = ev.relatedTarget;\n\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc.activeElement;\n    }\n\n    if (!elementContains(root.current, relatedTarget)) {\n      internalState.hasFocus = false;\n    }\n  };\n  /** Root div focus handler (doesn't need useCallback since it's for a native element) */\n\n\n  var onRootFocusCapture = function (ev) {\n    var _a;\n\n    (_a = props.onFocusCapture) === null || _a === void 0 ? void 0 : _a.call(props, ev);\n\n    if (ev.target === firstBumper.current) {\n      focusBumper(true);\n    } else if (ev.target === lastBumper.current) {\n      focusBumper(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target;\n    }\n  };\n  /** Called to restore focus on unmount or props change. (useEventCallback ensures latest prop values are used.) */\n\n\n  var returnFocusToInitiator = useEventCallback(function (elementToFocusOnDismiss) {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function (value) {\n      return internalState.focusStackId !== value;\n    });\n\n    if (!doc) {\n      return;\n    }\n\n    var activeElement = doc.activeElement;\n\n    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === 'function' && ( // only restore focus if the current focused element is within the FTZ, or if nothing is focused\n    elementContains(root.current, activeElement) || activeElement === doc.body)) {\n      focusElementAsync(elementToFocusOnDismiss);\n    }\n  });\n  /** Called in window event handlers. (useEventCallback ensures latest prop values are used.) */\n\n  var forceFocusOrClickInTrap = useEventCallback(function (ev) {\n    // be sure to use the latest values here\n    if (disabled) {\n      return;\n    }\n\n    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {\n      var targetElement = ev.target;\n\n      if (targetElement && !elementContains(root.current, targetElement)) {\n        focusFTZ();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  }); // Update window event handlers when relevant props change\n\n  React.useEffect(function () {\n    var disposables = [];\n\n    if (forceFocusInsideTrap) {\n      disposables.push(on(window, 'focus', forceFocusOrClickInTrap, true));\n    }\n\n    if (!isClickableOutsideFocusTrap) {\n      disposables.push(on(window, 'click', forceFocusOrClickInTrap, true));\n    }\n\n    return function () {\n      disposables.forEach(function (dispose) {\n        return dispose();\n      });\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]); // On prop change or first render, focus the FTZ and update focusStack if appropriate\n\n  React.useEffect(function () {\n    // Do nothing if disabled, or if it's a re-render and forceFocusInsideTrap is false\n    // (to match existing behavior, the FTZ handles first focus even if forceFocusInsideTrap\n    // is false, though it's debatable whether it should do this)\n    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root.current) {\n      return;\n    } // Transition from forceFocusInsideTrap / FTZ disabled to enabled (or initial mount)\n\n\n    FocusTrapZone.focusStack.push(internalState.focusStackId);\n    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;\n\n    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {\n      focusFTZ();\n    } // To match existing behavior, always return focus on cleanup (even if we didn't handle\n    // initial focus), but it's debatable whether that's correct\n\n\n    return function () {\n      return returnFocusToInitiator(elementToFocusOnDismiss);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, disabled]); // Handle modalization separately from first focus\n\n  React.useEffect(function () {\n    if (!disabled && enableAriaHiddenSiblings) {\n      var unmodalize = modalize(root.current);\n      return unmodalize;\n    }\n  }, [disabled, enableAriaHiddenSiblings, root]); // Cleanup lifecyle method for internalState.\n\n  useUnmount(function () {\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n  });\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);\n  return React.createElement(\"div\", __assign({\n    \"aria-labelledby\": props.ariaLabelledBy\n  }, getNativeProps(props, divProperties), {\n    ref: mergedRootRef,\n    onFocusCapture: onRootFocusCapture,\n    onBlurCapture: onRootBlurCapture\n  }), React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: firstBumper\n  })), children, React.createElement(\"div\", __assign({}, bumperProps, {\n    ref: lastBumper\n  })));\n});\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];","map":{"version":3,"mappings":"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","names":["React","elementContains","getNativeProps","divProperties","getFirstTabbable","getLastTabbable","getNextElement","focusAsync","getPropsWithDefaults","modalize","on","useId","useConst","useMergedRefs","useEventCallback","usePrevious","useUnmount","useDocument","COMPONENT_NAME","DEFAULT_PROPS","disabled","disableFirstFocus","forceFocusInsideTrap","isClickableOutsideFocusTrap","useComponentRef","componentRef","previouslyFocusedElement","focusFTZ","useImperativeHandle","focus","FocusTrapZone","forwardRef","propsWithoutDefaults","ref","root","useRef","firstBumper","lastBumper","mergedRootRef","doc","isFirstRender","_a","props","internalState","hasFocus","focusStackId","id","focusPreviouslyFocusedInnerElement","firstFocusableSelector","firstFocusableTarget","_b","disableRestoreFocus","ignoreExternalFocusing","enableAriaHiddenSiblings","bumperProps","style","pointerEvents","position","tabIndex","focusElementAsync","useCallback","element","current","previouslyFocusedElementInTrapZone","firstFocusableChild","querySelector","focusSelector","firstChild","focusBumper","isFirstBumper","nextFocusable","onRootBlurCapture","ev","onBlurCapture","relatedTarget","activeElement","onRootFocusCapture","onFocusCapture","target","currentTarget","returnFocusToInitiator","elementToFocusOnDismiss","focusStack","filter","value","body","forceFocusOrClickInTrap","slice","targetElement","preventDefault","stopPropagation","useEffect","disposables","push","window","forEach","unmodalize","ariaLabelledBy","children","displayName"],"sources":["C:\\Users\\Admin\\Desktop\\bookstore\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\FocusTrapZone\\FocusTrapZone.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  getPropsWithDefaults,\n  modalize,\n  on,\n} from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useEventCallback, usePrevious, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport type { IRefObject } from '../../Utilities';\nimport type { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\n\ninterface IFocusTrapZoneInternalState {\n  previouslyFocusedElementInTrapZone?: HTMLElement;\n  hasFocus: boolean;\n  /** ID tracked in focusStack. Don't respect prop updates in case the ID changes while the FTZ is active. */\n  focusStackId: string;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst DEFAULT_PROPS = {\n  disabled: false,\n  disableFirstFocus: false,\n  forceFocusInsideTrap: true,\n  isClickableOutsideFocusTrap: false,\n};\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focusFTZ: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus: focusFTZ,\n    }),\n    [focusFTZ, previouslyFocusedElement],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  /**\n   * Stack of active FocusTrapZone identifiers, exposed for testing purposes only.\n   * (This is always set, just marked as optional to avoid a cast in the component definition.)\n   * @internal\n   */\n  focusStack?: string[];\n} = React.forwardRef<HTMLDivElement, IFocusTrapZoneProps>((propsWithoutDefaults, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const doc = useDocument();\n\n  const isFirstRender = usePrevious(false) ?? true;\n\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>({\n    hasFocus: false,\n    focusStackId: useId('ftz-', props.id),\n  });\n\n  const {\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus,\n    forceFocusInsideTrap,\n    focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector,\n    firstFocusableTarget,\n    // eslint-disable-next-line deprecation/deprecation\n    disableRestoreFocus = props.ignoreExternalFocusing,\n    isClickableOutsideFocusTrap,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focusElementAsync = React.useCallback((element: HTMLElement) => {\n    if (element !== firstBumper.current && element !== lastBumper.current) {\n      focusAsync(element);\n    }\n  }, []);\n\n  /**\n   * Callback to force focus into FTZ (named to avoid overlap with global focus() callback).\n   * useEventCallback always returns the same callback reference but updates the implementation\n   * every render to avoid stale captured values.\n   */\n  const focusFTZ = useEventCallback(() => {\n    if (!root.current) {\n      return; // not done mounting\n    }\n\n    const { previouslyFocusedElementInTrapZone } = internalState;\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusElementAsync(previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (typeof firstFocusableTarget === 'string') {\n      firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n    } else if (firstFocusableTarget) {\n      firstFocusableChild = firstFocusableTarget(root.current);\n    } else if (firstFocusableSelector) {\n      const focusSelector =\n        typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector();\n      firstFocusableChild = root.current.querySelector('.' + focusSelector);\n    }\n\n    // Fall back to first element if query selector did not match any elements.\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(\n        root.current,\n        root.current.firstChild as HTMLElement,\n        false,\n        false,\n        false,\n        true,\n      );\n    }\n\n    if (firstFocusableChild) {\n      focusElementAsync(firstFocusableChild);\n    }\n  });\n\n  /** Used in root div focus/blur handlers */\n  const focusBumper = (isFirstBumper: boolean) => {\n    if (disabled || !root.current) {\n      return;\n    }\n\n    const nextFocusable =\n      isFirstBumper === internalState.hasFocus\n        ? getLastTabbable(root.current, lastBumper.current!, true, false)\n        : getFirstTabbable(root.current, firstBumper.current!, true, false);\n\n    if (nextFocusable) {\n      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n        // This can happen when FTZ contains no tabbable elements.\n        // focusFTZ() will take care of finding a focusable element in FTZ.\n        focusFTZ();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n\n  /** Root div blur handler (doesn't need useCallback since it's for a native element) */\n  const onRootBlurCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onBlurCapture?.(ev);\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc!.activeElement as Element;\n    }\n    if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n      internalState.hasFocus = false;\n    }\n  };\n\n  /** Root div focus handler (doesn't need useCallback since it's for a native element) */\n  const onRootFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onFocusCapture?.(ev);\n\n    if (ev.target === firstBumper.current) {\n      focusBumper(true);\n    } else if (ev.target === lastBumper.current) {\n      focusBumper(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  /** Called to restore focus on unmount or props change. (useEventCallback ensures latest prop values are used.) */\n  const returnFocusToInitiator = useEventCallback((elementToFocusOnDismiss: HTMLElement | null) => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack!.filter(value => internalState.focusStackId !== value);\n\n    if (!doc) {\n      return;\n    }\n\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !disableRestoreFocus &&\n      typeof elementToFocusOnDismiss?.focus === 'function' &&\n      // only restore focus if the current focused element is within the FTZ, or if nothing is focused\n      (elementContains(root.current, activeElement) || activeElement === doc.body)\n    ) {\n      focusElementAsync(elementToFocusOnDismiss);\n    }\n  });\n\n  /** Called in window event handlers. (useEventCallback ensures latest prop values are used.) */\n  const forceFocusOrClickInTrap = useEventCallback((ev: FocusEvent | MouseEvent): void => {\n    // be sure to use the latest values here\n    if (disabled) {\n      return;\n    }\n    if (internalState.focusStackId === FocusTrapZone.focusStack!.slice(-1)[0]) {\n      const targetElement = ev.target as HTMLElement | null;\n      if (targetElement && !elementContains(root.current, targetElement)) {\n        focusFTZ();\n        internalState.hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  });\n\n  // Update window event handlers when relevant props change\n  React.useEffect(() => {\n    const disposables: Array<() => void> = [];\n\n    if (forceFocusInsideTrap) {\n      disposables.push(on(window, 'focus', forceFocusOrClickInTrap, true));\n    }\n    if (!isClickableOutsideFocusTrap) {\n      disposables.push(on(window, 'click', forceFocusOrClickInTrap, true));\n    }\n\n    return () => {\n      disposables.forEach(dispose => dispose());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);\n\n  // On prop change or first render, focus the FTZ and update focusStack if appropriate\n  React.useEffect(() => {\n    // Do nothing if disabled, or if it's a re-render and forceFocusInsideTrap is false\n    // (to match existing behavior, the FTZ handles first focus even if forceFocusInsideTrap\n    // is false, though it's debatable whether it should do this)\n    if (disabled || (!isFirstRender && !forceFocusInsideTrap) || !root.current) {\n      return;\n    }\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled (or initial mount)\n    FocusTrapZone.focusStack!.push(internalState.focusStackId);\n\n    const elementToFocusOnDismiss = props.elementToFocusOnDismiss || (doc!.activeElement as HTMLElement | null);\n\n    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {\n      focusFTZ();\n    }\n\n    // To match existing behavior, always return focus on cleanup (even if we didn't handle\n    // initial focus), but it's debatable whether that's correct\n    return () => returnFocusToInitiator(elementToFocusOnDismiss);\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, disabled]);\n\n  // Handle modalization separately from first focus\n  React.useEffect(() => {\n    if (!disabled && enableAriaHiddenSiblings) {\n      const unmodalize = modalize(root.current!);\n      return unmodalize;\n    }\n  }, [disabled, enableAriaHiddenSiblings, root]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);\n\n  return (\n    <div\n      // this is above the native props spread so props['aria-labelledby'] will override it if provided\n      aria-labelledby={props.ariaLabelledBy}\n      // native props include onFocus, onBlur, className\n      {...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties)}\n      ref={mergedRootRef}\n      onFocusCapture={onRootFocusCapture}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n});\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"]},"metadata":{},"sourceType":"module"}